module Guards where

import Data.Int

import Language.Atom
import Language.Sally

-- Main Driver Function ------------------------------------------------

main :: IO ()
main = do
  putStrLn "Compiling GUARDS to C... (guards.{c,h})"
  compileToC  -- defined below

  putStrLn "Compiling GUARDS to Sally... (guards.mcmt)"
  let sallyCfg = defaultCfg
  compileToSally "guards" sallyCfg "guards.mcmt" guards Nothing
  putStrLn "Done."


-- Configuration for the C Code Generator ------------------------------

-- | Invoke the atom compiler
compileToC :: IO ()
compileToC = do
    _ <- compile "guards" cfg guards
    return ()
  where
    cfg = defaults { cCode = prePostCode }
    prePostCode _ _ _ =
      ( unlines [ "#include <stdio.h>"
                , "#include <unistd.h>"
                , ""
                , "// ---- BEGIN of source automatically generated by Atom ----"
                ]
      , unlines [ "// ---- END of source automatically generated by Atom ----"
                , ""
                , "int main(int argc, char **argv) {"
                , "  // call guards() once per second"
                , "  while(1) { guards(); usleep(1000); }"
                , "}"
                ]
      )


-- GUARDS Model ----------------------------------------------------------

-- | Top level rule
guards :: Atom ()
guards = do
  -- setup channel for communication between source and receiver
  (cin, cout) <- channel "chan" Int64

  -- The following sub-atoms all run during each period of the parent atom
  -- 'guards':

  -- declare the producer
  producer cin

  -- declare the consumer
  consumer cout


-- Producer ------------------------------------------------------------

producerPeriod :: Int
producerPeriod = 2

-- | Producer node
producer :: ChanInput  -- ^ channel input that producer will put messages on
         -> Atom ()
producer c = period producerPeriod . atom "producer" $ do
  count <- var "count" zero    -- declare a local variable
  probe "producer.count" (value count)
  writeChannel c (value count)  -- put 'count' on the channel
  incr count                    -- increment count (order w/ writeChannel
                                -- doesn't matter
  printAllProbes


-- Consumer ------------------------------------------------------------

consumerPeriod :: Int
consumerPeriod = 1

consumer :: ChanOutput  -- ^ channel output to listen to
         -> Atom ()
consumer c = period consumerPeriod . atom "consumer" $ do
  -- declare some local variables that are referenced by the sub-atoms below
  evenCount <- var "evenCount" zero
  probe "consumer.evens" (value evenCount)
  thirdEvenCount <- var "thirdEvenCount" zero
  probe "consumer.third_evens" (value thirdEvenCount)
  cycleCount <- var "cycleCount" zero
  probe "consumer.cycles" (value cycleCount)

  let zeroC  = Const zero
  let twoC   = Const two
  let threeC = Const three

  -- this sub-atom functions as a transition guarded by listening to the
  -- channel
  atom "listen_for_evens" $ do
    --
    -- Guard only on the channel containing a message
    cond $ fullChannel c
    let m = readChannel c
        v = value evenCount
    evenCount <== mux ((mod_ m twoC) ==. zeroC) (1 + v) v
    -- evenCount <== mux (v ==. zeroC) m twoC  -- ok w/ sally
    incr cycleCount

  -- this sub-atom is guarded on an expression of the local variable
  -- 'evenCount'
  atom "observe_third_evens" $ do
    cond $ (mod_ (value evenCount) threeC) ==. zeroC
    -- cond $ (value evenCount) ==. threeC  -- ok w/ sally
    incr thirdEvenCount

  printAllProbes


-- Utility Stuff -------------------------------------------------------

zero, two, three :: Int64
zero   = 0
two    = 2
three  = 3

printAllProbes :: Atom ()
printAllProbes = mapM_ printProbe =<< probes
