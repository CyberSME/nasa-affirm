% SAL model of OM(1)
%
% Oral Messages 1 algorithm
% version 5
%
% Notes:
%   * parametrized number of relays 'n' and receivers 'k'
%   * communication is modeled through a REAL time clock module and a
%     calendar automata that keeps track of messages and delivery times
%   * attempted to minimize number of state vars
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%   * byzantine faults are modeled through the message-read mechanism
%
% Authors: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2016)
%          Lee Pike                            , Galois Inc. (2016)


%
% Parameters:
%
% num_relays = # of relays
% num_recvs  = # of receivers
%
om1_cal {; num_relays: nznat, num_recvs: nznat}: CONTEXT =
BEGIN


%=== Nodes and IDs -----------------------------------------------===

% IDs for nodes
IDENTITY:  TYPE     = [0..(num_relays+num_recvs)];

% Relay IDs
source_id: IDENTITY = 0;

RELAYS: TYPE = [1..num_relays];
relay_id(n: nznat): RELAYS = n;  % map relay # to relay ID
id_relay(i: RELAYS): nznat = i;  % invert ^^^
majority_relays : nznat = (num_relays DIV 2) + 1;  % # relays needed for majority

% Receiver IDs
RECEIVERS: TYPE = [(num_relays+1)..(num_relays+num_recvs)];
receiver_id(k: nznat): RECEIVERS = num_relays + k;  % map receiver # to ID
id_receiver(i: RECEIVERS): nznat = i - num_relays;  % invert ^^^

% Helper functions for identification
is_source?(i: IDENTITY):   BOOLEAN = i = source_id;
is_relay?(i: IDENTITY):    BOOLEAN = 1 <= i AND i <= num_relays;
is_receiver?(i: IDENTITY): BOOLEAN = num_relays+1 <= i;


%=== Channels ----------------------------------------------------===

% We allocate one channel (ID) for each physical channel in the system,
% plus one for each "self-channel" that each receiver uses to execute in
% an atomic block (see the 'receiver' MODULEs below).
%
% let n = num_relays
%     k = num_recvs
%
% channel IDs
%
%   1            - n          : source -> n relays
%   (n+1)        - (n+k)      : relay 1 -> k receivers  : relay i -> recv j is
%   (n+1+k)      - (n+2k)     : relay 2 -> k receivers  : n+(i-1)k+j
%    .              .         :  .
%   (n+1+(n-1)k) - (n+nk)     : relay n -> k receivers
%   (n+1+nk)     - (n+(n+1)k) : receiver -> self
%
num_channels : nznat = num_relays + (num_relays+1)*num_recvs;
CHANNEL: TYPE = [1..num_channels];

% Determine if there is a channel from node ID i -> j. This is fixed at
% compile time based on the topology of the system.
linked?(i:IDENTITY, j:IDENTITY): BOOLEAN =
     (i = 0           AND is_relay?(j))
  OR (is_relay?(i)    AND is_receiver?(j))
  OR (is_receiver?(i) AND i = j);

% Compute channel ID from the (src, dest) pair
%
% precondition: linked?(i,j) == True
chan(i:IDENTITY, j:IDENTITY): CHANNEL =
  IF is_source?(i) THEN  % source -> relay chans are 1, 2, ... num_relays
    j
  ELSIF is_relay?(i) THEN
    num_relays + (id_relay(i) - 1)*num_recvs + id_receiver(j)
  ELSE  % i = j is a receiver
    id_receiver(i) + num_relays*(num_recvs + 1)
  ENDIF;

% Is the channel attached on either end to a receiver
is_receiver_channel?(c: CHANNEL): BOOLEAN =
  c > num_relays;

%=== Time --------------------------------------------------------===

% Time is modeled by non-negative integers
% -1 is reserved as an invalid time
% -2 is reserved as an atomic "out-of-band" time
TIME: TYPE = { t: INTEGER | t >= -2 };
invalid_time: TIME = -1;
atomic_time: TIME = -2;
msg_delay: TIME = 1;


%=== Faults ------------------------------------------------------===

FAULTS: TYPE = ARRAY IDENTITY OF BOOLEAN;


%=== Messages and Values -----------------------------------------===

% values recieved by relays and receivers
%
% MESSAGES is modeled as an uninterpreted type to support arbitrary
% faulty values

MESSAGE: TYPE = { m: INTEGER | m >= -1 };
% some named messages
good_msg: MESSAGE = 0;
missing:  MESSAGE = -1;

% these messages are emitted by the faulty nodes
FAULT_MESSAGE: TYPE = { x: MESSAGE | x >= 0 };
uninterp_msg(x: TIME, i: IDENTITY, j: IDENTITY): FAULT_MESSAGE;

is_faulty_msg?(m: MESSAGE): BOOLEAN = m > 0;


%=== Calendar Automata -------------------------------------------===

% Calendar data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.

CALENDAR: TYPE =
  [# msg  : ARRAY CHANNEL of MESSAGE,  % contents of message
     time : ARRAY CHANNEL of TIME      % time for delivery
  #];

empty_calendar: CALENDAR =
  (# msg  := [[c:CHANNEL] missing],
     time := [[c:CHANNEL] invalid_time]
  #);


%=== Calendar API ------------------------------------------------===


msg(s: TIME, cal: CALENDAR, f: FAULTS, i:IDENTITY, j:IDENTITY): MESSAGE =
  IF f[i] THEN
    uninterp_msg(s, i, j)  % return uninterpreted message
  ELSE
    cal.msg[chan(i,j)]     % return correct message
  ENDIF;

% Helper functions for getting/setting the calendar
null?(cal: CALENDAR, c: CHANNEL): BOOLEAN =
  cal.msg[c] = missing AND cal.time[c] = invalid_time;

% Is the given time the minimum among all valid times on the calendar?
is_next_time?(cal:CALENDAR, t:TIME): BOOLEAN =
      (FORALL (c:CHANNEL): NOT null?(cal,c) => t <= cal.time[c])
  AND (EXISTS (c:CHANNEL): NOT null?(cal,c) AND t = cal.time[c]);

delivery(cal: CALENDAR, i:IDENTITY, j:IDENTITY): TIME =
  cal.time[chan(i,j)];

% Is there a regular event i -> j yet to occur at the given time?
% Returns FALSE if
%
%     A) the pair i,j has no channel between them OR
%     B) the current time is 'atomic_time'
%
node_event?(cal:CALENDAR, i:IDENTITY, j:IDENTITY, t:TIME): BOOLEAN =
      linked?(i,j)
  AND is_next_time?(cal,t)
  AND NOT null?(cal,chan(i,j))
  AND delivery(cal,i,j) = t
  AND t /= atomic_time;

% is there an event yet to occur at the given time?
event_pending?(cal:CALENDAR, t:TIME): BOOLEAN =
  (EXISTS (c:CHANNEL): cal.msg[c] /= missing AND cal.time[c] = t);

% Am I in atomic mode?
i_am_atomic?(cal: CALENDAR, i: IDENTITY, t: TIME): BOOLEAN =
      EXISTS (j: IDENTITY): linked?(i,j) AND cal.time[chan(j,i)] = atomic_time
  AND t = atomic_time;

% send a message with given delay
msg_send_delta(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME, d:TIME):
CALENDAR =
  cal WITH .msg[chan(i,j)]  := m
      WITH .time[chan(i,j)] := t + d;

% default msg_send function has 'msg_delay' delay
msg_send(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME): CALENDAR =
  msg_send_delta(cal, i, j, m, t, msg_delay);

% add a 'preemtive' message (or interrupt) to the calendar. This action
% prevents transitions from occuring except in the 'atomic' section of the
% calling module.
msg_send_interrupt(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  msg_send_delta(cal, i, j, good_msg, atomic_time, 0);

msg_consume(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  cal WITH .msg[chan(i,j)]  := missing
      WITH .time[chan(i,j)] := invalid_time;


%===  Message broadcast functions  ===%

% broadcast a message from the source to each relay
msg_source_bcast_aux(cal: CALENDAR, m: MESSAGE, t: TIME, i: nznat, n: nznat):
CALENDAR =
  IF i < n
    THEN LET cal1:CALENDAR = msg_send(cal, source_id, i, m, t)
         IN  msg_source_bcast_aux(cal1, m, t, i+1, n)
    ELSE cal
  ENDIF;

msg_source_bcast(cal: CALENDAR, m: MESSAGE, t: TIME): CALENDAR =
  msg_source_bcast_aux(cal, m, t, relay_id(1), relay_id(1)+num_relays);

% broadcast a message from a relay ID 'i' to each receiver
msg_relay_bcast_aux(cal: CALENDAR, r: RELAYS, m: MESSAGE, t: TIME, i: nznat, n: nznat):
CALENDAR =
  IF i < n
    THEN LET cal1:CALENDAR = msg_send(cal, r, i, m, t)
         IN  msg_relay_bcast_aux(cal1, r, m, t, i+1, n)
    ELSE cal
  ENDIF;

msg_relay_bcast(cal: CALENDAR, r: RELAYS, m: MESSAGE, t: TIME): CALENDAR =
  msg_relay_bcast_aux(cal, r, m, t, receiver_id(1), receiver_id(1)+num_recvs);


%===----------------------------------------------------------------===
%       Transition System
%===----------------------------------------------------------------===

%
% The 'clock' module gives the general its message and manages the
% advance of time.
clock: MODULE =
BEGIN
    GLOBAL
      cal: CALENDAR,
      t:   TIME,
      f:   FAULTS
    INPUT
      source_done: BOOLEAN,
      relays_done: ARRAY RELAYS OF BOOLEAN,
      receivers_done: ARRAY RECEIVERS OF BOOLEAN
INITIALIZATION
    cal = empty_calendar;
    t = 0;
TRANSITION
    [
      advance_time:
        NOT is_next_time?(cal,t) --> t' IN { s:TIME | is_next_time?(cal,s) }
    []
      % allow clock to stutter once the system reaches the end of one round
      stutter:
        source_done AND
        (FORALL (i:RELAYS): relays_done[i]) AND
        (FORALL (i:RECEIVERS): receivers_done[i])
        -->  % nothing
    ]
END;

% 'source' sends a message (good_msg) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  t: TIME
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      source_broadcast:
      NOT source_done AND t = 0 -->
        cal' = msg_source_bcast(cal, good_msg, t);
        source_done' = TRUE
    ]
END;


relay[i: RELAYS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
      relay_done: BOOLEAN,
      latch: MESSAGE
INITIALIZATION
    latch      = missing;
    relay_done = FALSE
TRANSITION
    [
      relay_broadcast:
      (NOT relay_done) AND node_event?(cal, source_id, i, t) -->
        latch' = msg(t, cal, f, source_id, i);
        cal' = LET m:MESSAGE     = msg(t, cal, f, source_id, i)  IN
               LET cal1:CALENDAR = msg_relay_bcast(cal, i, m, t) IN
               msg_consume(cal1, source_id, i);
        relay_done' = TRUE
    ]
END;

% Receiver modes:
%
%   - 'receiving' message buffer is not yet full
%   - 'voting'    buffer is full; computing majority vote over the buffer
%   - 'done'      voting is complete and 'vote' is set with result
%
RECEIVER_MODES: TYPE = {receiving, voting, done};

receiver[p:RECEIVERS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
        buffer: ARRAY RELAYS of MESSAGE,
        vote: MESSAGE,
        receiver_done: BOOLEAN,
        counter: [0..num_relays],
        ix: [1..(num_relays+1)]
    LOCAL
        mode: RECEIVER_MODES,
        buffer_size: [0..num_relays],
        candidate: MESSAGE,
        pc: [0..(num_relays+1)]
INITIALIZATION
    % outputs
    mode = receiving;
    receiver_done = FALSE;
    vote = missing;
    % locals
    buffer = [[r:RELAYS] missing];  % init empty buffer
    buffer_size = 0;
    candidate = missing;
    counter = 0;
    ix = 1;
    pc = 0;
TRANSITION
    [
      %----------------------------------------------------------------
      % Receive a message from a relay
      %
      % When 'buffer' is full send a self- message with delivery
      % 'atomic_time'. This acquires the atomic lock so the following
      % transitions are enabled.
      %----------------------------------------------------------------

   ([] (i:RELAYS):
      receiver_recv:
      mode = receiving AND node_event?(cal, i, p, t) AND buffer[i] = missing -->
        buffer'[i]   = msg(t, cal, f, i, p);
        buffer_size' = buffer_size + 1;
        cal'         = IF buffer_size' = num_relays  % buffer is full
                          THEN LET cal1: CALENDAR = msg_consume(cal, i, p)
                               IN  msg_send_interrupt(cal1, p, p)
                          ELSE msg_consume(cal, i, p)
                       ENDIF;
        mode'        = IF buffer_size' = num_relays  % buffer is full
                         THEN voting
                         ELSE receiving
                       ENDIF;
      )
    []
      %----------------------------------------------------------------
      % drop incoming message if buffer[i] is full
      %----------------------------------------------------------------

   ([] (i:RELAYS):
      receiver_recv:
      mode = receiving AND node_event?(cal, i, p, t) AND buffer[i] /= missing -->
        cal' = msg_consume(cal, i, p);
      )
    []
      %----------------------------------------------------------------
      % The majority vote logic is unrolled in the following
      % transitions
      %----------------------------------------------------------------

      receiver_vote_0:
      mode = voting AND pc = 0 AND i_am_atomic?(cal, p, t) -->
        candidate' = missing;
        counter' = 0;
        ix' = 1;
        pc' = pc + 1
    []
      receiver_vote_loop:
          mode = voting
      AND pc > 0
      AND relay_id(1) <= ix AND ix <= relay_id(num_relays)
      AND i_am_atomic?(cal, p, t) -->

        % Factor the assignments to 'candidate' and 'counter' out of the
        % following psuedocode (based on the ADSL 'iVote' computation):
        %
        % if (buffer[ix] == candidate)
        %   counter += 1;
        % else if (counter == 0) {
        %   candidate = buffer[ix];
        %   counter   = 1;
        % }
        % else
        %   counter -= 1;
        %

        candidate' = IF buffer[ix] = candidate
                       THEN candidate
                     ELSIF counter = 0
                       THEN buffer[ix]
                       ELSE candidate
                     ENDIF;
        counter'   = IF buffer[ix] = candidate
                       THEN counter+1
                     ELSIF counter = 0
                       THEN 1
                       ELSE counter-1
                     ENDIF;

        ix' = ix + 1;
        pc' = pc + 1;
    []
        receiver_exit:
            mode = voting
        AND pc > num_relays+1
        AND ix > relay_id(num_relays)
        AND i_am_atomic?(cal, p, t) -->
          cal' = msg_consume(cal, p, p);  % release the atomic lock
          vote' = candidate;
          mode' = done;
          receiver_done' = TRUE
    ]
END;


%===----------------------------------------------------------------===
%       System
%===----------------------------------------------------------------===

% asyncronous composition is used to better model message passing
system: MODULE =
        clock
     [] source
     [] (WITH OUTPUT relays_done: ARRAY RELAYS OF BOOLEAN
         WITH OUTPUT latches: ARRAY RELAYS OF MESSAGE
           ([] (x:RELAYS): RENAME relay_done TO relays_done[x]
                           IN RENAME latch TO latches[x]
                           IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY RECEIVERS OF BOOLEAN
         WITH OUTPUT counters:       ARRAY RECEIVERS OF [0..num_relays]
         WITH OUTPUT ixs:            ARRAY RECEIVERS OF [1..(num_relays+1)]
         WITH OUTPUT buffers:        ARRAY RECEIVERS of ARRAY RELAYS of MESSAGE
         WITH OUTPUT votes:          ARRAY RECEIVERS of MESSAGE
           ([] (x:RECEIVERS):  RENAME vote TO votes[x]
                               IN RENAME buffer TO buffers[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN RENAME counter TO counters[x]
                               IN RENAME ix TO ixs[x]
                               IN receiver[x]));


%===----------------------------------------------------------------===
%       Syncronous Observer
%===----------------------------------------------------------------===

% First, some utility functions used in stating the properties we want to
% prove.

% How many of a certain message are in the buffer?
cntBuf(ix: RELAYS, max: RELAYS, buffer: ARRAY RELAYS of MESSAGE, m: MESSAGE): NATURAL =
  IF ix > num_relays OR ix > max
    THEN 0
    ELSIF buffer[ix] = m
      THEN cntBuf(ix+1, max, buffer, m) + 1
      ELSE cntBuf(ix+1, max, buffer, m)
  ENDIF;

has_majority?(buf: ARRAY RELAYS OF MESSAGE): BOOLEAN =
  EXISTS (i:RELAYS):
    cntBuf(relay_id(1), relay_id(num_relays), buf, buf[i]) >=
      num_relays DIV 2 + 1;

m_is_majority(buf: ARRAY RELAYS OF MESSAGE, m: MESSAGE): BOOLEAN =
  cntBuf(relay_id(1), relay_id(num_relays), buf, m) >=
    num_relays DIV 2 + 1;

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: ARRAY RELAYS OF BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    buffers: ARRAY RECEIVERS OF ARRAY RELAYS OF MESSAGE,
    votes: ARRAY RECEIVERS OF MESSAGE,
    f: FAULTS
  OUTPUT
    v_ok: BOOLEAN,
    a_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  v_ok = TRUE;
  a_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
      (    v_ok
       AND FORALL (x:RECEIVERS): receivers_done[x]
       AND (NOT votes[x]=good_msg)
       AND (NOT f[source_id])) -->
         v_ok' = FALSE
  []
    no_agreement:
      (    a_ok
       AND FORALL (x:RECEIVERS): receivers_done[x]
       AND EXISTS (x,y:RECEIVERS): 
             has_majority?(buffers[x]) AND has_majority?(buffers[y])
             AND votes[x] /= votes[y]) -->
         a_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
          not_done
      AND source_done
      AND (FORALL (i:RELAYS): relays_done[i])
      AND (FORALL (r:RECEIVERS): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;


ABSTRACT_STATE: TYPE = {a1, a2, a3, a3b, a4, a5, bad};

abstractor: MODULE =
BEGIN
  INPUT
    cal: CALENDAR,
    f: ARRAY IDENTITY OF BOOLEAN,
    source_done: BOOLEAN,
    latches: ARRAY RELAYS OF MESSAGE,
    relays_done: ARRAY RELAYS OF BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    buffers: ARRAY RECEIVERS OF ARRAY RELAYS OF MESSAGE,
    votes: ARRAY RECEIVERS OF MESSAGE
  OUTPUT
    A1, A2, A3, A3b, A4, A5: BOOLEAN
  DEFINITION

    % No messages have been sent or received yet
    A1 =     (FORALL (c: CHANNEL): null?(cal, c))
         AND NOT source_done
         AND (FORALL (i: RELAYS):
                NOT relays_done[i]
                AND latches[i] = missing)
         AND (FORALL (r: RECEIVERS):
                NOT receivers_done[r]
                AND votes[r] = missing
                AND (FORALL (i: RELAYS): buffers[r][i] = missing));

    % source has sent it's message
    A2 =     (FORALL (c: CHANNEL): null?(cal, c) <=> is_receiver_channel?(c))
         AND source_done
         AND (FORALL (i: RELAYS):
                NOT relays_done[i]
                AND latches[i] = missing)
         AND (FORALL (i: RECEIVERS):
                NOT receivers_done[i]
                AND votes[i] = missing)
         AND (FORALL (i: RELAYS, j: RECEIVERS): buffers[j][i] = missing);

    % at least one relay is done; no receivers are done
    % XXX remove fault + latch clauses to external lemma (also A4, A5)
    A3 =     source_done
         AND (FORALL (i: RELAYS): relays_done[i] =>
                null?(cal, chan(source_id, i))
                AND latches[i] /= missing)
         AND (EXISTS (i: RELAYS): relays_done[i])
         AND (FORALL (r: RECEIVERS): NOT receivers_done[r]
                AND null?(cal, chan(r,r))
                AND votes[r] = missing)
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                   (NOT relays_done[i] AND null?(cal, chan(i,j))           AND buffers[j][i] = missing)
                OR (    relays_done[i] AND cal.msg[chan(i,j)] = latches[i] AND buffers[j][i] = missing)
                OR (    relays_done[i] AND null?(cal, chan(i,j))           AND
buffers[j][i] /= missing AND (NOT f[i] => buffers[j][i] = latches[i]))
             );

    % all relays are done, but no receivers are done
    A3b =      source_done
          AND (FORALL (i: RELAYS): relays_done[i]
                 AND null?(cal, chan(source_id, i))
                 AND latches[i] /= missing)
          AND (FORALL (r: RECEIVERS):
                 NOT receivers_done[r]
                 AND votes[r] = missing)
          AND (FORALL (i: RELAYS, j: RECEIVERS):
                    (cal.msg[chan(i,j)] = latches[i] AND buffers[j][i] = missing)
                 OR (null?(cal, chan(i,j))           AND buffers[j][i] /= missing AND (NOT f[i] => buffers[j][i] = latches[i]))
             );

    % all relays are done; at least one receiver is done and one is not done
    A4 =     source_done
         AND (FORALL (i: RELAYS): relays_done[i]
                AND null?(cal, chan(source_id, i))
                AND latches[i] /= missing)
         AND (EXISTS (r: RECEIVERS): receivers_done[r])
         AND (FORALL (r: RECEIVERS): receivers_done[r] =>
                (EXISTS (i: RELAYS): votes[r] = buffers[r][i])
                AND (FORALL (i: RELAYS): null?(cal, chan(i,r)))
                AND (FORALL (i: RELAYS): NOT f[i] => buffers[r][i] = latches[i])
                AND null?(cal, chan(r,r)))
         AND (EXISTS (r: RECEIVERS): NOT receivers_done[r])
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                   (cal.msg[chan(i,j)] = latches[i] AND buffers[j][i] = missing)
                OR (null?(cal, chan(i,j))           AND buffers[j][i] /= missing AND (NOT f[i] => buffers[j][i] = latches[i]))
             );

    % all nodes are done
    A5 =     source_done
         AND (FORALL (i: RELAYS): relays_done[i]
                AND null?(cal, chan(source_id, i))
                AND latches[i] /= missing)
         AND (FORALL (r: RECEIVERS): receivers_done[r]
                AND (EXISTS (i: RELAYS): votes[r] = buffers[r][i])
                AND null?(cal, chan(r,r)))
         AND (FORALL (i: RELAYS, j: RECEIVERS): null?(cal, chan(i,j))
                AND buffers[j][i] /= missing
                AND (NOT f[i] => buffers[j][i] = latches[i]));
  TRANSITION
    [ ELSE --> ]

END;


abstract_monitor: MODULE =
BEGIN
  INPUT A1, A2, A3, A3b, A4, A5: BOOLEAN
  LOCAL state: ABSTRACT_STATE
  INITIALIZATION
    state = a1
  TRANSITION
    [
      state = a1 -->
        state' = IF      A1' THEN a1
                   ELSIF A2' THEN a2
                   ELSE           bad
                   ENDIF
    []
      state = a2 -->
        state' = IF      A2' THEN a2
                   ELSIF A3' THEN a3
                   ELSE           bad
                   ENDIF
    []
      state = a3 -->
        state' = IF      A3'  THEN a3
                   ELSIF A3b' THEN a3b
                   ELSE            bad
                   ENDIF
    []
      state = a3b -->
        state' = IF      A3b' THEN a3b
                   ELSIF A4'  THEN a4
                   ELSE            bad
                   ENDIF
    []
      state = a4 -->
        state' = IF      A4' THEN a4
                   ELSIF A5' THEN a5
                   ELSE           bad
                   ENDIF
    []
      state = a5 -->
        state' = IF      A5' THEN a5
                   ELSE           bad
                   ENDIF
    []
      % state = bad
      ELSE -->
    ]
END;


system_obs : MODULE = system || observer || abstractor || abstract_monitor;


%===--------------------------------------------------------------===
%       Verification
%===--------------------------------------------------------------===

% Options passed to each 'sal-inf-bmc' invocation by the runproof script
% may be given here.
%
% runproof: --disable-traceability
%

%==  Abstraction Lemmas  ==

% sal-inf-bmc  -d 1 om1_cal abstract_init
abstract_init: LEMMA system_obs |- A1;

% sal-inf-bmc -i  -d 1 om1_cal abstract_a1
abstract_a1:   LEMMA system_obs |- G(state = a1 => A1);

% sal-inf-bmc -i  -d 1 om1_cal abstract_a2
abstract_a2:   LEMMA system_obs |- G(state = a2 => A2);

% sal-inf-bmc -i  -d 1 om1_cal abstract_a3
abstract_a3:   LEMMA system_obs |- G(state = a3 => A3);

% sal-inf-bmc -i  -d 1 om1_cal abstract_a3b
abstract_a3b:   LEMMA system_obs |- G(state = a3b => A3b);

% sal-inf-bmc -i  -d 1 om1_cal abstract_a4
abstract_a4:   LEMMA system_obs |- G(state = a4 => A4);

% sal-inf-bmc -i  -d 1 om1_cal abstract_a5
abstract_a5:   LEMMA system_obs |- G(state = a5 => A5);

% 'abstract_invt' is used to show that the abstraction is sound
%
% Proved: (using many lemmas)
% sal-inf-bmc -i -d 1 \
%     -l abstract_a1 -l abstract_a2 -l abstract_a3 \
%     -l abstract_a3b -l abstract_a4 -l abstract_a5 \
%     -l lemma_conj -l lemma_source -l lemma_relays \
%     -l lemma_receivers -l receiver_mode_invt \
%     om1_cal abstract_invt
abstract_invt: LEMMA system_obs |- G(state /= bad);

% Proved:
% sal-inf-bmc -i -d 1 \
%     -l abstract_a1 -l abstract_a2 -l abstract_a3 -l abstract_a3b \
%     -l abstract_a4 -l abstract_a5 -l lemma_conj -l receiver_mode_invt \
%     om1_cal abstract_all
abstract_all: LEMMA system_obs |-
  G(    (state = a1 => A1)
    AND (state = a2 => A2)
    AND (state = a3 => A3)
    AND (state = a3b => A3b)
    AND (state = a4 => A4)
    AND (state = a5 => A5)
    AND (state /= bad));

% We'd like to prove the following lemma using the abstraction
% order of doneness states
%   1. before any relay is done, the source must be
%   2. before any receiver is done, all relays must be
%
% Proved:
% not used in main proofs: sal-inf-bmc -i -d 1 -l abstract_invt om1_cal order_of_done
order_of_done: LEMMA
system_obs |-
  G(    (EXISTS (i: RELAYS): relays_done[i]) => source_done
    AND (EXISTS (r: RECEIVERS): receivers_done[r] =>
           FORALL (i: RELAYS): relays_done[i]
        )
  );


%==  Helpers  ==

% Maximum fault assumption: there is at most 1 faulty node
mfa(f: FAULTS): BOOLEAN =
  FORALL (i,j: IDENTITY):
    f[i] AND f[j] => i = j;

% Validity constraint: there is at most 1 faulty node and it is not the source
% node
validity(f: FAULTS): BOOLEAN =
  mfa(f) AND NOT f[source_id];


%==  Basic Invariants  ==

global_time_not_null(t: TIME): BOOLEAN = t /= -1;

% All event times listed on the calendar are either in the (weak) future, or
% are "atomic times".
monotonic_time(cal: CALENDAR, t: TIME): BOOLEAN =
  FORALL (c: CHANNEL): is_next_time?(cal, cal.time[c]) =>
    cal.time[c] = atomic_time OR cal.time[c] >= t;

% Invariant: a channel is missing a message iff. it lists an the invalid time
missing_cal(cal: CALENDAR): BOOLEAN =
  FORALL (c: CHANNEL): cal.msg[c] = missing <=> cal.time[c] = invalid_time;

% Invariant: there exists at most one event on the calendar with "atomic time"
unique_atomic(cal: CALENDAR): BOOLEAN =
  FORALL (i,j: CHANNEL): cal.time[i] = -2 AND cal.time[j] = -2 => i = j;


% Not clear if useful
% Proved:
% sal-inf-bmc -i  -d 1 -l lemma_conj om1_cal lemma_source
lemma_source: LEMMA
system_obs |-
  G(NOT source_done => (FORALL (i: RELAYS): null?(cal, chan(source_id, i))));


% Not clear if useful
% Proved:
% sal-inf-bmc -i  -d 1 -l lemma_conj om1_cal lemma_relays
lemma_relays: LEMMA
system_obs |-
  G(FORALL(i: RELAYS):
          (NOT relays_done[i] => FORALL (r: RECEIVERS):
                                   null?(cal, chan(i, r)) AND buffers[r][i] = missing)
      AND (    relays_done[i] => FORALL (r: RECEIVERS):
                                      (null?(cal, chan(i, r))
                                       AND buffers[r][i] /= missing)
                                   OR (NOT null?(cal, chan(i, r))
                                       AND buffers[r][i] = missing))
  );


% Not clear if useful
% Proved:
% sal-inf-bmc -i  -d 1 -l lemma_conj om1_cal lemma_receivers
lemma_receivers: LEMMA
system_obs |-
  G(FORALL(r: RECEIVERS):
          (receivers_done[r] <=> mode[r] = done)
      AND (receivers_done[r] => null?(cal, chan(r, r)))
      % AND (FORALL (i: RELAYS): NOT relays_done[i] => NOT receivers_done[r]
      %                                                AND null?(cal, chan(r, r)))
      % AND (receivers_done[r] => FORALL (i: RELAYS): null?(cal, chan(i, r)))
  );


% Very useful
% Proved:
% sal-inf-bmc -i  -d 1 om1_cal.sal lemma_conj
lemma_conj: LEMMA system_obs |-
  G(    monotonic_time(cal, t)
    AND global_time_not_null(t)
    AND missing_cal(cal)
    AND unique_atomic(cal)
   );


% Proved:
% sal-inf-bmc -i  -d 1 -l lemma_conj om1_cal.sal fault_propagation
fault_propagation: LEMMA system_obs |-
  G(
    % no faulty messages are ever stored here
    (FORALL (j:RELAYS):
       NOT is_faulty_msg?(cal.msg[chan(source_id, j)]))
    AND (FORALL (i:RECEIVERS):
           FORALL (j:RELAYS):
             (is_faulty_msg?(buffers[i][j])  % faulty msg read into buffer comes
               => f[j] OR f[source_id])      % from either faulty relay or faulty
                                             % source
             AND (is_faulty_msg?(cal.msg[chan(j, i)])
                   => f[source_id])));       % faulty msg in cal must come from
                                             % faulty source


% LEMMA: # of current received messages + # of slots with 'missing' = total
% number of relays.
%
% Proved:
% sal-inf-bmc -i  -d 1 -l lemma_conj om1_cal.sal missing_buffer_size
missing_buffer_size: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i: RELAYS):
        LET a:IDENTITY = relay_id(1) IN
        LET b:IDENTITY = relay_id(num_relays) IN
        buffer_size[r] +
        cntBuf(a, b, buffers[r], missing) = num_relays);


% Proved:
% sal-inf-bmc -i  -d 1 -l fault_propagation om1_cal.sal one_faulty_in_buffers
one_faulty_in_buffers: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i,j: RELAYS):
            is_faulty_msg?(buffers[r][i])
        AND is_faulty_msg?(buffers[r][j])
        AND validity(f)
        => i = j);


% Main invarinant of the each receiver's mode cycle
%
% Proved:
% sal-inf-bmc -i -d 1 \
%     -l missing_buffer_size -l abstract_invt \
%     om1_cal.sal receiver_mode_invt
receiver_mode_invt: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
    (    NOT receivers_done[r]
             % receiver is receiving messages from relays
     AND (   (    mode[r] = receiving
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 0
              AND buffer_size[r] < num_relays
              AND candidate[r] = missing
             )
             % receiver buffer is full, switched to voting mode
          OR (    mode[r] = voting
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 0
              AND buffer_size[r] = num_relays
              AND candidate[r] = missing
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
             % receiver starts voting by initializing state variables
          OR (    mode[r] = voting
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 1
              AND buffer_size[r] = num_relays
              AND candidate[r] = missing
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
             % receiver is in the process of tallying vote
          OR (    mode[r] = voting
              AND counters[r] <= cntBuf(relay_id(1), ixs[r]-1,
                                        buffers[r], candidate[r])
              AND ixs[r] <= num_relays+1
              AND pc[r] >= 1
              AND candidate[r] /= missing
              AND EXISTS (i: RELAYS): (buffers[r][i] = candidate[r] AND i < ixs[r])
              AND buffer_size[r] = num_relays
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
         )
    )
    % receiver has finished voting
    OR (    receivers_done[r]
        AND mode[r] = done
        AND ixs[r] = relay_id(num_relays)+1
        AND pc[r] >= 1
        AND votes[r] = candidate[r]
        AND buffer_size[r] = num_relays
        AND FORALL (i: RELAYS): buffers[r][i] /= missing
       )
   );


% Additional invariant to 'receiver_mode_invt' that holds whenever there is a
% majority in the voting buffer.
%
% Proved
% sal-inf-bmc -i -d 1 \
%     -l missing_buffer_size -l receiver_mode_invt -l one_faulty_in_buffers \
%     -l majority_vote_invt \
%     om1_cal.sal exists_majority
%
exists_majority: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      mode[r] = done AND has_majority?(buffers[r])
      => m_is_majority(buffers[r], votes[r])
   );


% This is the main invariant of the fast majority vote algorithm MJRTY, see
% [1] Section VI.
%
% In the terminology of [1], I = ixs[r]-1 and K = counters[r], # in support of
% CAND = b.
%
% [1] R. Boyer and J. Moore. MJRTY - A Fast Majority Vote Algorithm. SRI Technical
%     Report 32. February 1981.
%
% Proved through parameters {6,6}
% sal-inf-bmc -i -d 1 \
%     -l receiver_mode_invt -l one_faulty_in_buffers \
%     om1_cal.sal majority_vote_invt
%
majority_vote_invt: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      % b = # of delegates so far in support of candidate[r]
      LET b:NATURAL = cntBuf(relay_id(1), ixs[r]-1, buffers[r], candidate[r]) IN
      mode[r] = voting =>
        % 1)
        %   by construction: relay_id(1) <= ixs[r] <= relay_id(num_relays)+1
        % 2)
            (relay_id(1) < ixs[r] => candidate[r] /= missing)
        % 3)
        AND 0 <= b - counters[r]
        % 4)
        AND b - counters[r] <= (ixs[r]-1-counters[r]) DIV 2
        % 5)
        AND (FORALL (i: RELAYS): buffers[r][i] /= candidate[r] =>
               cntBuf(relay_id(1), ixs[r]-1, buffers[r], buffers[r][i]) <=
                 (ixs[r]-1-counters[r]) DIV 2
            )
  );


% Proved!
% sal-inf-bmc -i -d 1 \
%     -l exists_majority -l receiver_mode_invt -l one_faulty_in_buffers \
%     om1_cal.sal candidate_good
%
candidate_good: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      mode[r] = done AND validity(f) => votes[r] = good_msg);


%=====  Main Theorem: Validity
%
% The system satisfies the validity property under the condition that at most
% one node is faulty and that the source is not faulty.
%
% Proved!
% sal-inf-bmc -i  -d 1 -l candidate_good -l receiver_mode_invt om1_cal.sal validity
%
validity: THEOREM system_obs |- G(validity(f) => v_ok);




%===----------------------------------------------------------
%     Agreement lemmas
%===----------------------------------------------------------

% Proved!
% not used in main proofs
% XXX sal-inf-bmc -i  -d 1 -l fault_propagation om1_cal.sal fault_origin
fault_origin: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i,j: RELAYS):
            is_faulty_msg?(buffers[r][i])
        AND is_faulty_msg?(buffers[r][j])
        AND mfa(f)
        => f[source_id] OR i = j);

% The message sent by relay 'i' is consistent across all receivers, regardless
% of whether 'i' is faulty (faults show up upon reading the message from the
% channel).
%
% XXX LP: not sure if this is useful.
% Proved
% not used in main proofs: sal-inf-bmc -i  -d 1 om1_cal.sal relay_chans

relay_chans: LEMMA system_obs |-
  G(FORALL (r0,r1: RECEIVERS):
      FORALL (i: RELAYS):
           cal.msg[chan(i,r0)] = missing
        OR cal.msg[chan(i,r1)] = missing
        OR cal.msg[chan(i,r1)] = cal.msg[chan(i,r0)]);


% Assume source and relay 'i' are *not* faulty. Whenever two receivers have
% obtained values from relay 'i', they are equal.
%
% BJ: I think this trivially follows from 'fault_propagation' b/c if source and
% relay are good, the only possible value in buffer[-][i] is 'good' and, of
% course, good = good.
%
% BJ: trying to prove the weaker (not assuming source is non-faulty) version,
% I think it requires a latch at the relay to save the sent value...
%
% Proved!
% not used in main proofs
% XXX sal-inf-bmc -i -ice -d 1 -l abstract_all -l lemma_conj om1_cal.sal relay_buffers

relay_buffers: LEMMA system_obs |-
  G(FORALL (r0,r1: RECEIVERS):
      FORALL (i: RELAYS):
        (   buffers[r0][i] /= missing
        AND buffers[r1][i] /= missing
        AND NOT f[i] =>
          buffers[r0][i] = buffers[r1][i])
  );


%=====  Main Theorem: Agreement
%
% The system satisfies the agreement property under the condition that at most
% one node is faulty (including, possibly, the source)
%
%
% Unproved (param version 2016-03-28)
% sal-inf-bmc -i -d 1 \
%     -l abstract_all -l lemma_conj -l fault_propagation \
%     -l receiver_mode_invt -l majority_vote_invt -l exists_majority \
%     om1_cal agreement
%
agreement: THEOREM system_obs |- G(mfa(f) => a_ok);



%===--------------------------------------------------------------===
%       Tests
%
% TESTS for bounded model checker; these are non-THEOREMS
%
%===--------------------------------------------------------------===

% components finish eventually:
source_test:    THEOREM system |- G(NOT source_done);
relays_test:    THEOREM system |- G(NOT FORALL (i:RELAYS): relays_done[i]);

% counterexample at depth ?
time_test: THEOREM system |- G(t < 2);  % for msg_delay = 1 this implies we
                                        % only advance as far as the relay broadcast
% counterexample at depth ?
recv_test: THEOREM system |- G(NOT FORALL (i:RECEIVERS): receivers_done[i]);

% everyone finishes eventually:
%   true to depth ?
%   counterexample at depth ?
all_done_test: THEOREM system_obs |- G(not_done);

END
