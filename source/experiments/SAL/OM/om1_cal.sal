% SAL model of OM(1) using asyncronous message passing
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)

om1_cal: CONTEXT =
BEGIN

n: NATURAL = 5;  % num relays
k: NATURAL = 5;  % num receivers

% IDs for nodes
nodes: TYPE = [0..n+k+1];
source_id: nodes = 0;
ivote_id: nodes = n+k+1;

% IDs for relays
relay_id_min: nodes = 1;
relay_id_max: nodes = n;
relays: TYPE = [1..n];

% IDs for receivers
receiver_id_min: nodes = n+1;
receiver_id_max: nodes = n+k;
receivers: TYPE = [n+1..n+k];

% values recieved by relays and receivers
vals: TYPE = [0..n+1];
relay_vals: TYPE = ARRAY relays OF vals;
recv_vals: TYPE = ARRAY receivers OF vals;

% Fault Model
missing_v: vals = 0;
def_msg: vals = 0;
correct_v: vals = n+1;

%----------------------------------------------------------------------
% Calendar Automata
%
% calendar data structure for communication between nodes
%
% chans[i][j] = status of the link between node i and j
%   -> TRUE means one msg waiting to be recieved
%   -> FALSE means no msg pending
% msgs[i][j] = content of the message
%
%-------------------------------------------------------------

calendar: TYPE =
  [# chans: ARRAY nodes OF ARRAY nodes OF BOOLEAN,
     msgs:  ARRAY nodes OF ARRAY nodes OF vals
   #];

empty_calendar : calendar =
  (# chans := [[i: nodes] [[j:nodes] FALSE]],
     msgs  := [[i: nodes] [[j:nodes] def_msg]]
  #);

msg_pending?(cal: calendar, i: nodes, j:nodes): BOOLEAN =
  cal.chans[i][j];
msg_read(cal: calendar, i: nodes, j:nodes): vals =
  cal.msgs[i][j];
msg_send(cal: calendar, i: nodes, j:nodes, m:vals): calendar =
  cal WITH .chans[i][j] := TRUE
      WITH .msgs[i][j]  := m;
msg_consume(cal: calendar, i: nodes, j:nodes): calendar =
  cal WITH .chans[i][j] := FALSE;

is_source?(i: nodes):   BOOLEAN = i = source_id;
is_relay?(i: nodes):    BOOLEAN = relay_id_min <= i AND i <= relay_id_max;
is_receiver?(i: nodes): BOOLEAN = receiver_id_min <= i AND i <= receiver_id_max;

% Special broadcast functions
msg_bcast_relays(cal: calendar, m: vals): calendar =
  (# chans := [[i:nodes] [[j:nodes] IF is_source?(i) AND is_relay?(j) THEN TRUE
                                    ELSE cal.chans[i][j] ENDIF]],
     msgs  := [[i:nodes] [[j:nodes] IF is_source?(i) AND is_relay?(j) THEN m
                                    ELSE cal.msgs[i][j] ENDIF]]
  #);

msg_bcast_receivers(cal: calendar, m: vals, r:relays): calendar =
  (# chans := [[i:nodes] [[j:nodes] IF i=r AND is_receiver?(j) THEN TRUE
                                    ELSE cal.chans[i][j] ENDIF]],
     msgs  := [[i:nodes] [[j:nodes] IF i=r AND is_receiver?(j) THEN m
                                    ELSE cal.msgs[i][j] ENDIF]]
  #);

%----------------------------------------------------------------------
% State Machine
%----------------------------------------------------------------------

controller: MODULE =
BEGIN
    GLOBAL cal: calendar
    OUTPUT s_in: vals  % message value for source to send
INITIALIZATION
    s_in = correct_v;
    cal = empty_calendar
TRANSITION
    [
      ELSE -->
    ]
END;

% 'source' sends a message (s_in) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: calendar
    INPUT  s_in: vals
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      NOT source_done -->
        cal' = msg_bcast_relays(cal, s_in);
        source_done' = TRUE
    []
      ELSE -->
    ]
END;

relay[i: relays]: MODULE =
BEGIN
    GLOBAL cal: calendar
    OUTPUT relay_done: BOOLEAN
INITIALIZATION
      relay_done = FALSE
TRANSITION
    [
      (NOT relay_done) AND msg_pending?(cal, source_id, i) -->
        % broadcast message to receivers and consume in one step
        cal' = LET m:vals = msg_read(cal, source_id, i) IN
               LET cal1:calendar = msg_bcast_receivers(cal, m, i) IN
               msg_consume(cal1, source_id, i);
        relay_done' = TRUE
    []
      ELSE -->
    ]
END;

receiver_modes: TYPE = {wait_relay, wait_vote, done};

receiver[p:receivers]: MODULE =
BEGIN
    GLOBAL cal: calendar
    LOCAL
      recvd: relay_vals,
      mode: receiver_modes
    OUTPUT
      vote: vals,
      receiver_done: BOOLEAN
INITIALIZATION
    mode = wait_relay;
    receiver_done = FALSE;
    recvd = [[i:relays] missing_v]
TRANSITION
    [
      % call ivote' when incoming array is complete
      mode = wait_relay AND (FORALL (i:relays): recvd[i] /= missing_v) -->
        cal' = msg_send(cal, p, ivote_id, def_msg);
        mode' = wait_vote;
    []
      % collect return value from 'ivote'
      mode = wait_vote AND msg_pending?(cal, ivote_id, p) -->
        vote' = msg_read(cal, ivote_id, p);
        cal'  = msg_consume(cal, ivote_id, p);
        mode' = done
    []
      mode = done --> receiver_done' = TRUE
    []
      ELSE -->
    ]
END;

% asyncronous composition is used to better model message passing
system: MODULE =
   controller
     [] source
     [] (WITH OUTPUT relays_done: ARRAY relays OF BOOLEAN
           ([] (x:relays): RENAME relay_done TO relays_done[x] IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY receivers OF BOOLEAN
         WITH OUTPUT votes: recv_vals
           ([] (x:receivers):  RENAME vote TO votes[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN receiver[x]));


%----------------------------------------------------------------------
% Vote Count
%----------------------------------------------------------------------

candidate_bound: TYPE = vals;
counter_bound: TYPE = nodes;
pc_bound: TYPE = [0..100];  % ???

ivote: MODULE =
BEGIN
    GLOBAL cal : calendar
    LOCAL
        candidate : candidate_bound,  % var declared local in 'ivote'
        counter   : counter_bound,    % ditto
        vote_pc : pc_bound,       % pc for 'ivote'
        vote_pc_loop1 : pc_bound  % loop counter
    OUTPUT
        caller : receivers,  % corresponds to current caller
        busy : BOOLEAN       % busy counting?
    % TODO: get input from caller
    %DEFINITION
    %    arr = [[i:relays] vecs[i][caller]]
    INITIALIZATION
        vote_pc = -1;
        vote_pc_loop1 = -1
    TRANSITION
    [
        % receiver 'j' calles ivote
        ([] (j: receivers):
          (NOT busy) AND msg_pending?(cal, j, ivote_id) -->
            caller' = j;
            % ignore the msg contents
            cal' = msg_consume(cal, j, ivote_id);
            vote_pc' = 0;
            busy' = TRUE;
        )
    []
        vote_pc = 0 --> candidate' = 0;     vote_pc' = vote_pc + 1
    []
        vote_pc = 1 --> counter' = 0;       vote_pc' = vote_pc + 1
    []
        vote_pc = 2 --> vote_pc_loop1' = 0; vote_pc' = vote_pc + 1
    % []
    %     ...
    []
        ELSE -->
    ]
END;




%----------------------------------------------------------------------
% Syncronous Observer
%----------------------------------------------------------------------

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    votes : recv_vals
  OUTPUT
    ok : BOOLEAN
  INITIALIZATION
    ok = TRUE
  TRANSITION
  [
    % TODO: replace with asyncronous versions
    no_validity:
      NOT (FORALL (x:receivers): votes[x]=correct_v)
      --> ok' = FALSE
  []
    no_agreement:
      NOT (FORALL (x,y:receivers): votes[x]=votes[y])
      --> ok' = FALSE
  []
    ELSE -->
  ]
END;

observed_vaa: THEOREM (system || observer) |- G(ok);

ivote_test: THEOREM (system [] ivote) |- F(busy);  % ok to -d 10
ivote_test2: THEOREM (system [] ivote) |- G(NOT busy);

END
