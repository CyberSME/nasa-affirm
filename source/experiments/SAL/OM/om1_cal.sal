% SAL model of OM(1) using asyncronous message passing
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)

om1_cal: CONTEXT =
BEGIN

n: NATURAL = 5;  % num relays
k: NATURAL = 5;  % num receivers

% IDs for nodes
nodes: TYPE = [0..n+k+1];
source_id: nodes = 0;
ivote_id: nodes = n+k+1;

% IDs for relays
relay_id_min: nodes = 1;
relay_id_max: nodes = n;
relays: TYPE = [1..n];

% IDs for receivers
receiver_id_min: nodes = n+1;
receiver_id_max: nodes = n+k;
receivers: TYPE = [n+1..n+k];

% values recieved by relays and receivers
vals: TYPE = [0..n+1];
relay_vals: TYPE = ARRAY relays OF vals;
recv_vals: TYPE = ARRAY receivers OF vals;

% call stacks for 'ivote'
stack: TYPE = ARRAY receivers OF ARRAY relays OF vals;

% Fault Model
missing_v: vals = 0;
def_msg: vals = 0;
correct_v: vals = n+1;

%----------------------------------------------------------------------
% Calendar Automata
%
% calendar data structure for communication between nodes
%
% chans[i][j] = status of the link between node i and j
%   -> TRUE means one msg waiting to be recieved
%   -> FALSE means no msg pending
% msgs[i][j] = content of the message
%
%-------------------------------------------------------------

calendar: TYPE =
  [# chans: ARRAY nodes OF ARRAY nodes OF BOOLEAN,
     msgs:  ARRAY nodes OF ARRAY nodes OF vals
   #];

empty_calendar : calendar =
  (# chans := [[i: nodes] [[j:nodes] FALSE]],
     msgs  := [[i: nodes] [[j:nodes] def_msg]]
  #);

% Calendar API
msg_pending?(cal: calendar, i: nodes, j:nodes): BOOLEAN =
  cal.chans[i][j];
msg_read(cal: calendar, i: nodes, j:nodes): vals =
  cal.msgs[i][j];
msg_send(cal: calendar, i: nodes, j:nodes, m:vals): calendar =
  cal WITH .chans[i][j] := TRUE
      WITH .msgs[i][j]  := m;
msg_consume(cal: calendar, i: nodes, j:nodes): calendar =
  cal WITH .chans[i][j] := FALSE;

is_source?(i: nodes):   BOOLEAN = i = source_id;
is_relay?(i: nodes):    BOOLEAN = relay_id_min <= i AND i <= relay_id_max;
is_receiver?(i: nodes): BOOLEAN = receiver_id_min <= i AND i <= receiver_id_max;

% Special broadcast functions
msg_bcast_relays(cal: calendar, m: vals): calendar =
  (# chans := [[i:nodes] [[j:nodes] IF is_source?(i) AND is_relay?(j) THEN TRUE
                                    ELSE cal.chans[i][j] ENDIF]],
     msgs  := [[i:nodes] [[j:nodes] IF is_source?(i) AND is_relay?(j) THEN m
                                    ELSE cal.msgs[i][j] ENDIF]]
  #);

msg_bcast_receivers(cal: calendar, m: vals, r:relays): calendar =
  (# chans := [[i:nodes] [[j:nodes] IF i=r AND is_receiver?(j) THEN TRUE
                                    ELSE cal.chans[i][j] ENDIF]],
     msgs  := [[i:nodes] [[j:nodes] IF i=r AND is_receiver?(j) THEN m
                                    ELSE cal.msgs[i][j] ENDIF]]
  #);

%----------------------------------------------------------------------
% State Machine
%----------------------------------------------------------------------

controller: MODULE =
BEGIN
    GLOBAL
        cal: calendar,
        ivote_stack: stack
    OUTPUT
        s_in: vals  % message value for source to send
INITIALIZATION
    cal = empty_calendar;
    s_in = correct_v;
    ivote_stack = [[r:receivers] [[rr:relays] missing_v]]
TRANSITION
    [
      ELSE -->
    ]
END;

% 'source' sends a message (s_in) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: calendar
    INPUT  s_in: vals
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      NOT source_done -->
        cal' = msg_bcast_relays(cal, s_in);
        source_done' = TRUE
    []
      ELSE -->
    ]
END;

relay[i: relays]: MODULE =
BEGIN
    GLOBAL cal: calendar
    OUTPUT relay_done: BOOLEAN
INITIALIZATION
    relay_done = FALSE
TRANSITION
    [
      (NOT relay_done) AND msg_pending?(cal, source_id, i) -->
        % broadcast message to receivers and consume in one step
        cal' = LET m:vals = msg_read(cal, source_id, i) IN
               LET cal1:calendar = msg_bcast_receivers(cal, m, i) IN
               msg_consume(cal1, source_id, i);
        relay_done' = TRUE
    []
      ELSE -->
    ]
END;

receiver_modes: TYPE = {wait_relay, wait_vote, done};

receiver[p:receivers]: MODULE =
BEGIN
    GLOBAL
        cal: calendar,
        ivote_stack: stack
    LOCAL
        mode: receiver_modes,
        recvd: relay_vals
    OUTPUT
        vote: vals,
        receiver_done: BOOLEAN
    DEFINITION
        recvd = ivote_stack[p]
INITIALIZATION
    mode = wait_relay;
    receiver_done = FALSE;
TRANSITION
    [
      % rec'v message from relay
      ([] (i:relays):
        mode = wait_relay AND msg_pending?(cal, i, p) -->
          recvd'[i] = msg_read(cal, i, p);
          cal' = msg_consume(cal, i, p)
      )
    []
      % call ivote' when incoming array is complete
      mode = wait_relay AND (FORALL (i:relays): recvd[i] /= missing_v) -->
        cal' = msg_send(cal, p, ivote_id, def_msg);
        mode' = wait_vote;
    []
      % collect return value from 'ivote'
      mode = wait_vote AND msg_pending?(cal, ivote_id, p) -->
        vote' = msg_read(cal, ivote_id, p);
        cal'  = msg_consume(cal, ivote_id, p);
        mode' = done
    []
      mode = done --> receiver_done' = TRUE
    []
      ELSE -->
    ]
END;


%----------------------------------------------------------------------
% Vote Count
%----------------------------------------------------------------------

candidate_bound: TYPE = vals;
counter_bound: TYPE = nodes;
ivote_pc_range: TYPE = [0..100];  % ??? compute at compile time
ivote_input_size: INTEGER = n;
ivote_ix_range: TYPE = [0..ivote_input_size+1];

ivote: MODULE =
BEGIN
    GLOBAL cal : calendar
    INPUT  ivote_stack: stack
    LOCAL
        % ivory state
        candidate: vals,           % vars declared local in 'ivote'
        counter: ivote_ix_range,
        arr: relay_vals,
        % aux state
        ivote_pc: ivote_pc_range,  % pc for 'ivote'
        ix: ivote_ix_range         % loop counter
    OUTPUT
        caller : receivers,  % corresponds to current caller
        busy : BOOLEAN       % busy counting?
    DEFINITION
        arr = ivote_stack[caller]
INITIALIZATION
    ivote_pc = -1;
    ix = -1
TRANSITION
    [
        % receiver 'j' calles ivote
        ([] (j: receivers):
          (NOT busy) AND msg_pending?(cal, j, ivote_id) -->
            caller' = j;
            % ignore the msg contents
            cal' = msg_consume(cal, j, ivote_id);
            ivote_pc' = 0;
            busy' = TRUE;
        )
    []
        ivote_pc = 0 --> candidate' = 0; ivote_pc' = ivote_pc + 1
    []
        ivote_pc = 1 --> counter' = 0;   ivote_pc' = ivote_pc + 1
    []
        ivote_pc = 2 --> ix' = 0;        ivote_pc' = ivote_pc + 1
    []
        ivote_pc > 2 AND 0 <= ix AND ix <= ivote_input_size -->
          candidate' = IF arr[ix]=candidate
                         THEN candidate
                       ELSIF counter=0
                         THEN arr[ix]
                       ELSE candidate ENDIF;
          counter'   = IF arr[ix]=candidate
                         THEN counter+1
                       ELSIF counter=0
                         THEN 0
                       ELSE counter-1 ENDIF;
          ix' = ix + 1;
          ivote_pc' = ivote_pc + 1
    []
        ivote_pc > 2 AND ix > ivote_input_size -->
          cal' = msg_send(cal, ivote_id, caller, candidate);
          ivote_pc' = -1;
          busy' = FALSE
    []
        ELSE -->
    ]
END;


%----------------------------------------------------------------------
% System
%----------------------------------------------------------------------

% asyncronous composition is used to better model message passing
system: MODULE =
   controller
     [] ivote
     [] source
     [] (WITH OUTPUT relays_done: ARRAY relays OF BOOLEAN
           ([] (x:relays): RENAME relay_done TO relays_done[x] IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY receivers OF BOOLEAN
         WITH OUTPUT votes: recv_vals
           ([] (x:receivers):  RENAME vote TO votes[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN receiver[x]));


%----------------------------------------------------------------------
% Syncronous Observer
%----------------------------------------------------------------------

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    receivers_done: ARRAY receivers OF BOOLEAN,
    votes: recv_vals
  OUTPUT
    ok: BOOLEAN
  INITIALIZATION
    ok = TRUE
  TRANSITION
  [
    no_validity:
      (FORALL (x:receivers): receivers_done[x]) AND
      (NOT (FORALL (x:receivers): votes[x]=correct_v)) -->
        ok' = FALSE
  []
    no_agreement:
      (FORALL (x:receivers): receivers_done[x]) AND
      (NOT (FORALL (x,y:receivers): votes[x]=votes[y])) -->
        ok' = FALSE
  []
    ELSE -->
  ]
END;

observed_vaa: THEOREM (system || observer) |- G(ok);
ivote_test: THEOREM  (system) |- F(busy);      % ok to depth 10
ivote_test2: THEOREM (system) |- G(NOT busy);  % ?

END
