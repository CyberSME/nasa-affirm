% SAL model of OM(1), version 2
%
% Oral Messages 1 algorithm
%
% ** WARNING ** may still contain bugs
%
% Notes:
%   * more economical encoding of channels than v1
%   * no faults are modeled
%   * channels are modeled using a (nodes x nodes) matrix called a 'calendar' (an
%     abuse of terminology since REAL time is not tracked)
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)

om1_cal_v2: CONTEXT =
BEGIN


%--- Parameters -----------------------------------------------------

% These parameters control the size of the system. Basic verification is
% tractable when n <= 3 and k <= 2. At this size, SAL reports number of system
% variables: 122, number of auxiliary variables: 20
%
n: NATURAL = 3;  % num relays
k: NATURAL = 2;  % num receivers


%--- Nodes and IDs --------------------------------------------------

% IDs for nodes
nodes: TYPE = [0..n+k+1];  % n relays, k receivers, 1 source, 1 vote procedure
source_id: nodes = 0;
ivote_id: nodes = n+k+1;

% IDs for relays
relay_id_min: nodes = 1;
relay_id_max: nodes = n;
relays: TYPE = [1..n];

% IDs for receivers
receiver_id_min: nodes = n+1;
receiver_id_max: nodes = n+k;
receivers: TYPE = [n+1..n+k];

% Helper functions for identification
is_source?(i: nodes):   BOOLEAN = i = source_id;
is_relay?(i: nodes):    BOOLEAN = relay_id_min <= i AND i <= relay_id_max;
is_receiver?(i: nodes): BOOLEAN = receiver_id_min <= i AND i <= receiver_id_max;
is_ivote?(i:nodes):     BOOLEAN = i = ivote_id;

%--- Messages and Values --------------------------------------------

% values recieved by relays and receivers
vals: TYPE = [0..n+1];
missing_v: vals = 0;    % no message present
correct_v: vals = n+1;  % intended message from source

relay_vals: TYPE = ARRAY relays OF vals;
recv_vals:  TYPE = ARRAY receivers OF vals;

% call stacks for 'ivote'
stack: TYPE = ARRAY receivers OF relay_vals;


%--- channel Automata ----------------------------------------------

% type indexing channels between nodes
channel_idx : TYPE = [nodes, nodes];

% the specific set of channels for this particular model
channel_set : TYPE =
  { x:channel_idx | (x.1 = source_id   AND is_relay?(x.2))    OR
                    (is_relay?(x.1)    AND is_receiver?(x.2)) OR
                    (is_receiver?(x.1) AND x.2 = ivote_id)    OR
                    (ivote_id = x.1    AND is_receiver?(x.2))
  };

% compute an ID for each tuple in the channel_set, need this to index into
% chans array
num_channels : INTEGER = k + k*n + 2*n;
channel_ids : TYPE = [0..num_channels-1];
channel_id(i: channel_set): channel_ids =
  IF i.1=source_id AND is_relay?(1.2)
    THEN i.2-relay_id_min  % 0..k-1
  ELSIF is_relay?(i.1) AND is_receiver?(i.2)
    THEN k + n*(i.1-relay_id_min) + (i.2-receiver_id_min)  % k..(k+k*n-1)
  ELSIF is_receiver?(i.1) AND i.2=ivote_id
    THEN k + k*n + (i.1-receiver_id_min)
    ELSE k + k*n + n + (i.2-receiver_id_min)
  ENDIF;

% empty : no message present
% ready : message ready to be consumed
channel_status : TYPE = {empty, ready};

% channels data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.
%
% chans[(i,j)] = status of the link between node i and j
% msgs[(i,j)] = content of the message (of type 'vals')
%
channels: TYPE =
  [#
     chans: ARRAY channel_ids OF channel_status,
     msgs:  ARRAY channel_ids OF vals
  #];

empty_channels : channels =
  (#
     chans := [[i:channel_ids] empty],
     msgs  := [[i:channel_ids] missing_v]
  #);

%--- channels API ---

msg_pending?(cha: channels, i: channel_set): BOOLEAN =
  cha.chans[channel_id(i)] = ready;

msg_read(cha: channels, i: channel_set): vals =
  cha.msgs[channel_id(i)];

% TODO: handle multiple concurrent messages from i -> j
msg_send(cha: channels, i: channel_set, m:vals): channels =
  cha WITH .chans[channel_id(i)] := ready
      WITH .msgs[channel_id(i)]  := m;

msg_consume(cha: channels, i: channel_set): channels =
  cha WITH .chans[channel_id(i)] := empty
      WITH .msgs[channel_id(i)]  := missing_v;

% Broadcast a message from the source to all the relays
msg_bcast_relays(cha: channels, m: vals): channels =
  (# chans := [[i:channel_ids] IF 0 <= i AND i < k THEN ready
                               ELSE cha.chans[i] ENDIF],
     msgs  := [[i:channel_ids] IF 0 <= i AND i < k THEN m
                               ELSE cha.msgs[i] ENDIF]
  #);

% Broadcast a message from relay 'r' to all receivers
msg_bcast_receivers(cha: channels, m: vals, r:relays): channels =
  (# chans := [[i:channel_ids] IF k+(r-relay_id_min)*n <= i AND i < k+(r-relay_id_min+1)*n THEN ready
                               ELSE cha.chans[i] ENDIF],
     msgs  := [[i:channel_ids] IF k+(r-relay_id_min)*n <= i AND i < k+(r-relay_id_min+1)*n THEN m
                               ELSE cha.msgs[i] ENDIF]
  #);

%----------------------------------------------------------------------
% State Machine
%----------------------------------------------------------------------

% The 'controller' is responsible for initialization of some global variables
% and for providing 'source' with the content of its message.
%
% Note: 'source_done', 'relays_done', etc... are modeling artifacts`
%
controller: MODULE =
BEGIN
    GLOBAL
      cha: channels,
      ivote_stack: stack
    INPUT
      source_done: BOOLEAN,
      relays_done: ARRAY relays OF BOOLEAN,
      receivers_done: ARRAY receivers OF BOOLEAN
    OUTPUT
      s_in: vals  % message value for source to send
INITIALIZATION
    cha = empty_channels;
    s_in = correct_v;
    ivote_stack = [[p:receivers] [[i:relays] missing_v]]
TRANSITION
    [
      % prevent deadlock after the components finish
      controller_else:
      source_done AND
        (FORALL (i:relays): relays_done[i]) AND
        (FORALL (r:receivers): receivers_done[r]) -->
    ]
END;

% Module 'source' represents the General, it sends a message (s_in) to all relays
source: MODULE =
BEGIN
    GLOBAL cha: channels
    INPUT  s_in: vals
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      source_broadcast:
      NOT source_done -->
        cha' = msg_bcast_relays(cha, s_in);
        source_done' = TRUE
    ]
END;

% Each relay broadcasts the message it receives to all the receiveres.
relay[i: relays]: MODULE =
BEGIN
    GLOBAL cha: channels
    OUTPUT relay_done: BOOLEAN
INITIALIZATION
    relay_done = FALSE
TRANSITION
    [
      relay_broadcast:
      (NOT relay_done) AND msg_pending?(cha, (source_id, i)) -->
        % broadcast message to receivers and consume in one step
        cha' = LET m:vals = msg_read(cha, (source_id, i)) IN
               LET cal1:channels = msg_bcast_receivers(cha, m, i) IN
               msg_consume(cal1, (source_id, i));
        relay_done' = TRUE
    ]
END;

% wait_relay means waiting for all relays to send their messages
% wait_vote  means waiting on the ivote machine to return an answer
receiver_modes: TYPE = {wait_relay, wait_vote, done};

% Each receiver collects messages it receives from the relays and, when it has
% them all, calls the 'ivote' function to compute a majority vote.
receiver[p:receivers]: MODULE =
BEGIN
    GLOBAL
      cha: channels,
      ivote_stack: stack
    LOCAL
      mode: receiver_modes
    OUTPUT
      vote: vals,
      receiver_done: BOOLEAN
INITIALIZATION
    mode = wait_relay;
    receiver_done = FALSE;
    vote = missing_v
TRANSITION
    [
      % rec'v message from relay
      ([] (i:relays):
        receiver_recv:
        mode = wait_relay AND msg_pending?(cha, (i, p)) -->
          ivote_stack'[p][i] = msg_read(cha, (i, p));
          cha' = msg_consume(cha, (i, p))
      )
    []
      % call ivote' when incoming array is complete
      % TODO: model how the Tower code determines the array is complete
      receiver_call_ivote:
      mode = wait_relay AND (FORALL (i:relays): ivote_stack[p][i] /= missing_v) -->
        cha'  = msg_send(cha, (p, ivote_id), missing_v);
        mode' = wait_vote
    []
      % collect return value from 'ivote'
      receiver_return_ivote:
      mode = wait_vote AND msg_pending?(cha, (ivote_id, p)) -->
        vote' = msg_read(cha, (ivote_id, p));
        cha'  = msg_consume(cha, (ivote_id, p));
        mode' = done
    []
      receiver_done:
      mode = done AND NOT receiver_done -->
        receiver_done' = TRUE
    ]
END;


%----------------------------------------------------------------------
% Vote Count
%----------------------------------------------------------------------

candidate_bound: TYPE = vals;
counter_bound: TYPE = nodes;
ivote_pc_range: TYPE = [0..100];  % ??? compute at compile time
ivote_input_size: INTEGER = n;
ivote_ix_range: TYPE = [0..ivote_input_size];

% Module 'ivote' models the Ivory function computing a fast majority vote over
% an array.
ivote: MODULE =
BEGIN
    GLOBAL cha : channels
    INPUT  ivote_stack: stack
    LOCAL
        % ivory state
        candidate: vals,           % vars declared local in 'ivote'
        counter: ivote_ix_range,
        arr: relay_vals,
        % aux state
        ivote_pc: ivote_pc_range,  % pc for 'ivote'
        ix: ivote_ix_range         % loop counter
    OUTPUT
        caller : receivers,   % corresponds to current caller
        ivote_busy : BOOLEAN  % busy counting?
    DEFINITION
        arr = ivote_stack[caller]
INITIALIZATION
    ivote_pc = 0;
    ivote_busy = FALSE
TRANSITION
    [
        % receiver 'j' calles ivote
        ([] (j: receivers):
          ivote_called:
          (NOT ivote_busy) AND msg_pending?(cha, (j, ivote_id)) -->
            caller' = j;
            % ignore the msg contents
            cha' = msg_consume(cha, (j, ivote_id));
            ivote_pc' = 0;
            ivote_busy' = TRUE
        )
    []
        ivote_pc_0:
        ivote_busy AND ivote_pc = 0 --> candidate' = 0; ivote_pc' = ivote_pc + 1
    []
        ivote_pc_1:
        ivote_busy AND ivote_pc = 1 --> counter' = 0;   ivote_pc' = ivote_pc + 1
    []
        ivote_pc_2:
        ivote_busy AND ivote_pc = 2 --> ix' = 0;        ivote_pc' = ivote_pc + 1
    []
        ivote_loop:
        ivote_busy AND ivote_pc > 2 AND 0 <= ix AND ix < ivote_input_size -->
          candidate' = IF arr[ix]=candidate
                         THEN candidate
                       ELSIF counter=0
                         THEN arr[ix]
                       ELSE candidate ENDIF;
          counter'   = IF arr[ix]=candidate
                         THEN counter+1
                       ELSIF counter=0
                         THEN 0
                       ELSE counter-1 ENDIF;
          ix' = ix + 1;
          ivote_pc' = ivote_pc + 1
    []
        ivote_return:
        ivote_busy AND ivote_pc > 2 AND ix = ivote_input_size -->
          cha' = msg_send(cha, (ivote_id, caller), candidate);
          ivote_busy' = FALSE
    ]
END;


%----------------------------------------------------------------------
% System
%----------------------------------------------------------------------

% asyncronous composition is used to better model message passing
system: MODULE =
   controller
     [] ivote
     [] source
     [] (WITH OUTPUT relays_done: ARRAY relays OF BOOLEAN
           ([] (x:relays): RENAME relay_done TO relays_done[x] IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY receivers OF BOOLEAN
         WITH OUTPUT votes: recv_vals
           ([] (x:receivers):  RENAME vote TO votes[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN receiver[x]));


%----------------------------------------------------------------------
% Syncronous Observer
%----------------------------------------------------------------------

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: ARRAY relays OF BOOLEAN,
    receivers_done: ARRAY receivers OF BOOLEAN,
    votes: recv_vals
  OUTPUT
    vaa_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  vaa_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
      (FORALL (x:receivers): receivers_done[x]) AND
      (NOT (FORALL (x:receivers): votes[x]=correct_v)) -->
        vaa_ok' = FALSE
  []
    no_agreement:
      (FORALL (x:receivers): receivers_done[x]) AND
      (NOT (FORALL (x,y:receivers): votes[x]=votes[y])) -->
        vaa_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
      source_done AND
      (FORALL (i:relays): relays_done[i]) AND
      (FORALL (r:receivers): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;

system_obs: MODULE = system || observer;


%--------------------------------------------------------------------
%  Verification
%--------------------------------------------------------------------

%---  Main Theorems  ---

% system eventually finishes (at which point vaa can be checked).
% Alternatively, the safety property 'not_all_done' listed below can be
% checked for counterexamples with bmc.
%   n = 3, k = 2: sal-smc om1_cal_v1 finish
%                 XXX proved (16.1 s)
%                 XXX sal-deadlock-checker om1_cal_v1 OK
finish: THEOREM system_obs |- F(NOT not_done);

% validity and agreement hold when the system is "done"
%   BDDs n = 3, k = 2: sal-smc om1_cal_v1 vaa
%                      proved (16.7 secs)
%                      sal-bmc -d 50 om1_cal_v1 vaa
%                      no counterexamples (169 secs)
vaa: THEOREM system_obs |- G(vaa_ok);


%--- Invariants ---

% TODO

%--- Tests for bounded model checker; these are non-THEOREMS  ---

% components finish eventually:
%   n=2, k=3: counter-ex depth 1
source_test:    THEOREM system_obs |- G(NOT source_done);
%   n=2, k=3: counter-ex depth 8
relays_test:    THEOREM system_obs |- G(NOT FORALL (i:relays): relays_done[i]);
%   n=2, k=3: counter-ex depth gg
receivers_test: THEOREM system_obs |- G(NOT FORALL (i:receivers): receivers_done[i]);

% everyone finishes eventually:
%   n=2, k=2: counterexample depth 
%   n=3, k=2: counterexample depth 
%   n=3, k=3: counterexample depth 
not_all_done: THEOREM system_obs |- G(not_done);

END
