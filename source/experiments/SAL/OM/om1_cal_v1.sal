% SAL model of OM(1)
%
% Oral Messages 1 algorithm
%
% Notes:
%   * no faults are modeled
%   * channels are modeled using a (nodes x nodes) matrix called a 'calendar' (an
%     abuse of terminology since REAL time is not tracked)
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)

om1_cal_v1: CONTEXT =
BEGIN


%--- Parameters -----------------------------------------------------

% These parameters control the size of the system. Basic verification is
% tractable when n <= 3 and k <= 2. At this size, SAL reports number of system
% variables: 262, number of auxiliary variables: 20
%
n: NATURAL = 3;  % num relays
k: NATURAL = 2;  % num receivers


%--- Nodes and IDs --------------------------------------------------

% IDs for nodes
nodes: TYPE = [0..n+k+1];  % n relays, k receivers, 1 source, 1 vote procedure
source_id: nodes = 0;
ivote_id: nodes = n+k+1;

% IDs for relays
relay_id_min: nodes = 1;
relay_id_max: nodes = n;
relays: TYPE = [1..n];

% IDs for receivers
receiver_id_min: nodes = n+1;
receiver_id_max: nodes = n+k;
receivers: TYPE = [n+1..n+k];

% Helper functions for identification
is_source?(i: nodes):   BOOLEAN = i = source_id;
is_relay?(i: nodes):    BOOLEAN = relay_id_min <= i AND i <= relay_id_max;
is_receiver?(i: nodes): BOOLEAN = receiver_id_min <= i AND i <= receiver_id_max;
is_ivote?(i:nodes):     BOOLEAN = i = ivote_id;


%--- Messages and Values --------------------------------------------

% values recieved by relays and receivers
vals: TYPE = [0..n+1];
missing_v: vals = 0;    % no message present
correct_v: vals = n+1;  % intended message from source

relay_vals: TYPE = ARRAY relays OF vals;
recv_vals:  TYPE = ARRAY receivers OF vals;

% call stacks for 'ivote'
stack: TYPE = ARRAY receivers OF relay_vals;


%--- Calendar Automata ----------------------------------------------

% Calendar data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.
%
% chans[i][j] = status of the link between node i and j
%   -> TRUE means one msg waiting to be recieved
%   -> FALSE means no msg pending
%
% msgs[i][j] = content of the message (of type 'vals')
calendar: TYPE =
  [# chans: ARRAY nodes OF ARRAY nodes OF BOOLEAN,
     msgs:  ARRAY nodes OF ARRAY nodes OF vals
   #];

empty_calendar : calendar =
  (# chans := [[i: nodes] [[j:nodes] FALSE]],
     msgs  := [[i: nodes] [[j:nodes] missing_v]]
  #);

% Calendar API
msg_pending?(cal: calendar, i: nodes, j:nodes): BOOLEAN =
  cal.chans[i][j];
msg_read(cal: calendar, i: nodes, j:nodes): vals =
  cal.msgs[i][j];
% TODO: possibility of overwrite
msg_send(cal: calendar, i: nodes, j:nodes, m:vals): calendar =
  cal WITH .chans[i][j] := TRUE
      WITH .msgs[i][j]  := m;
msg_consume(cal: calendar, i: nodes, j:nodes): calendar =
  cal WITH .chans[i][j] := FALSE
      WITH .msgs[i][j]  := missing_v;
chan_empty?(cal: calendar, i: nodes, j:nodes) : BOOLEAN =
  NOT cal.chans[i][j] AND cal.msgs[i][j] = missing_v;

% Broadcast a message from the source to all the relays
msg_bcast_relays(cal: calendar, m: vals): calendar =
  (# chans := [[i:nodes] [[j:nodes] IF is_source?(i) AND is_relay?(j) THEN TRUE
                                    ELSE cal.chans[i][j] ENDIF]],
     msgs  := [[i:nodes] [[j:nodes] IF is_source?(i) AND is_relay?(j) THEN m
                                    ELSE cal.msgs[i][j] ENDIF]]
  #);

% Broadcast a message from relay 'r' to all receivers
msg_bcast_receivers(cal: calendar, m: vals, r:relays): calendar =
  (# chans := [[i:nodes] [[j:nodes] IF i=r AND is_receiver?(j) THEN TRUE
                                    ELSE cal.chans[i][j] ENDIF]],
     msgs  := [[i:nodes] [[j:nodes] IF i=r AND is_receiver?(j) THEN m
                                    ELSE cal.msgs[i][j] ENDIF]]
  #);

%----------------------------------------------------------------------
% State Machine
%----------------------------------------------------------------------

% Notes:
%
% 'source_done', 'relays_done', etc... are for debugging and verification
%

controller: MODULE =
BEGIN
    GLOBAL
      cal: calendar,
      ivote_stack: stack
    INPUT
      source_done: BOOLEAN,
      relays_done: ARRAY relays OF BOOLEAN,
      receivers_done: ARRAY receivers OF BOOLEAN
    OUTPUT
      s_in: vals  % message value for source to send
INITIALIZATION
    cal = empty_calendar;
    s_in = correct_v;
    ivote_stack = [[p:receivers] [[i:relays] missing_v]]
TRANSITION
    [
      % prevent deadlock after the components finish
      controller_else:
      source_done AND
        (FORALL (i:relays): relays_done[i]) AND
        (FORALL (r:receivers): receivers_done[r]) -->
          % stutter
    ]
END;

% 'source' sends a message (s_in) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: calendar
    INPUT  s_in: vals
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      source_broadcast:
      NOT source_done -->
        cal' = msg_bcast_relays(cal, s_in);
        source_done' = TRUE
    ]
END;

relay[i: relays]: MODULE =
BEGIN
    GLOBAL cal: calendar
    OUTPUT relay_done: BOOLEAN
INITIALIZATION
    relay_done = FALSE
TRANSITION
    [
      relay_broadcast:
      (NOT relay_done) AND msg_pending?(cal, source_id, i) -->
        % broadcast message to receivers and consume in one step
        cal' = LET m:vals = msg_read(cal, source_id, i) IN
               LET cal1:calendar = msg_bcast_receivers(cal, m, i) IN
               msg_consume(cal1, source_id, i);
        relay_done' = TRUE
    ]
END;

% wait_relay means waiting for all relays to send their messages
% wait_vote  means waiting on the ivote machine to return an answer
% done       means vote has been computed
receiver_modes: TYPE = {wait_relay, wait_vote, done};

receiver[p:receivers]: MODULE =
BEGIN
    GLOBAL
        cal: calendar,
        ivote_stack: stack
    OUTPUT
        mode: receiver_modes,
        vote: vals,
        receiver_done: BOOLEAN
INITIALIZATION
    mode = wait_relay;
    receiver_done = FALSE;
    vote = missing_v
TRANSITION
    [
      % rec'v message from relay
      ([] (i:relays):
        receiver_recv:
        mode = wait_relay AND msg_pending?(cal, i, p) -->
          ivote_stack'[p][i] = msg_read(cal, i, p);
          cal' = msg_consume(cal, i, p)
      )
    []
      % call ivote' when incoming array is complete
      % TODO: model how the Tower code determines the array is complete
      receiver_call_ivote:
      mode = wait_relay AND (FORALL (i:relays): ivote_stack[p][i] /= missing_v) -->
        cal'  = msg_send(cal, p, ivote_id, missing_v);
        mode' = wait_vote
    []
      % collect return value from 'ivote'
      receiver_return_ivote:
      mode = wait_vote AND msg_pending?(cal, ivote_id, p) -->
        vote' = msg_read(cal, ivote_id, p);
        cal'  = msg_consume(cal, ivote_id, p);
        mode' = done
    []
      receiver_done:
      mode = done AND NOT receiver_done -->
        receiver_done' = TRUE
    ]
END;


%----------------------------------------------------------------------
% Vote Count
%----------------------------------------------------------------------

candidate_bound: TYPE = vals;
counter_bound: TYPE = nodes;
ivote_pc_range: TYPE = [0..100];  % ??? compute at compile time
ivote_input_size: INTEGER = n;
ivote_ix_range: TYPE = [0..ivote_input_size];

ivote: MODULE =
BEGIN
    GLOBAL cal : calendar
    INPUT  ivote_stack: stack
    LOCAL
        % ivory state
        candidate: vals,           % vars declared local in 'ivote'
        counter: ivote_ix_range,
        arr: relay_vals,
        % aux state
        ivote_pc: ivote_pc_range,  % pc for 'ivote'
        ix: ivote_ix_range         % loop counter
    OUTPUT
        caller : receivers,   % corresponds to current caller
        ivote_busy : BOOLEAN  % busy counting?
    DEFINITION
        arr = ivote_stack[caller]
INITIALIZATION
    ivote_pc = 0;
    ivote_busy = FALSE
TRANSITION
    [
        % receiver 'j' calls ivote
        ([] (j: receivers):
          ivote_called:
          (NOT ivote_busy) AND msg_pending?(cal, j, ivote_id) -->
            caller' = j;
            % ignore the msg contents
            cal' = msg_consume(cal, j, ivote_id);
            ivote_pc' = 0;
            ivote_busy' = TRUE
        )
    []
        ivote_pc_0:
        ivote_busy AND ivote_pc = 0 --> candidate' = 0; ivote_pc' = ivote_pc + 1
    []
        ivote_pc_1:
        ivote_busy AND ivote_pc = 1 --> counter' = 0;   ivote_pc' = ivote_pc + 1
    []
        ivote_pc_2:
        ivote_busy AND ivote_pc = 2 --> ix' = 0;        ivote_pc' = ivote_pc + 1
    []
        ivote_loop:
        ivote_busy AND ivote_pc > 2 AND 0 <= ix AND ix < ivote_input_size -->
          candidate' = IF arr[ix]=candidate
                         THEN candidate
                       ELSIF counter=0
                         THEN arr[ix]
                       ELSE candidate ENDIF;
          counter'   = IF arr[ix]=candidate
                         THEN counter+1
                       ELSIF counter=0
                         THEN 0
                       ELSE counter-1 ENDIF;
          ix' = ix + 1;
          ivote_pc' = ivote_pc + 1
    []
        ivote_return:
        ivote_busy AND ivote_pc > 2 AND ix = ivote_input_size -->
          cal' = msg_send(cal, ivote_id, caller, candidate);
          ivote_busy' = FALSE
    ]
END;


%----------------------------------------------------------------------
% System
%----------------------------------------------------------------------

% asyncronous composition is used to better model message passing
system: MODULE =
   controller
     [] ivote
     [] source
     [] (WITH OUTPUT relays_done: ARRAY relays OF BOOLEAN
           ([] (x:relays): RENAME relay_done TO relays_done[x] IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY receivers OF BOOLEAN
         WITH OUTPUT receiver_mode: ARRAY receivers OF receiver_modes
         WITH OUTPUT votes: recv_vals
           ([] (x:receivers):  RENAME vote TO votes[x]
                               IN RENAME mode TO receiver_mode[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN receiver[x]));


%----------------------------------------------------------------------
% Syncronous Observer
%----------------------------------------------------------------------

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: ARRAY relays OF BOOLEAN,
    receivers_done: ARRAY receivers OF BOOLEAN,
    votes: recv_vals
  OUTPUT
    vaa_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  vaa_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
      (FORALL (x:receivers): receivers_done[x]) AND
      (NOT (FORALL (x:receivers): votes[x]=correct_v)) -->
        vaa_ok' = FALSE
  []
    no_agreement:
      (FORALL (x:receivers): receivers_done[x]) AND
      (NOT (FORALL (x,y:receivers): votes[x]=votes[y])) -->
        vaa_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
      source_done AND
      (FORALL (i:relays): relays_done[i]) AND
      (FORALL (r:receivers): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;

system_obs : MODULE = system || observer;


%--------------------------------------------------------------------
%  Verification
%--------------------------------------------------------------------

%---  Main Theorems  ---

% system eventually finishes (at which point vaa can be checked).
% Alternatively, the safety property 'not_all_done' listed below can be
% checked for counterexamples with bmc.
%   n = 3, k = 2: sal-smc om1_cal_v1 finish
%                 proved (16.1 s)
%                 sal-deadlock-checker om1_cal_v1 OK
finish: THEOREM system_obs |- F(NOT not_done);

% validity and agreement hold when the system is "done"
%   BDDs n = 3, k = 2: sal-smc om1_cal_v1 vaa
%                      proved (16.7 secs)
%                      sal-bmc -d 50 om1_cal_v1 vaa
%                      no counterexamples (169 secs)
vaa: THEOREM system_obs |- G(vaa_ok);


%--- Invariants ---

% unused channels are empty:
%   n = 3, k = 2: sal-bmc -i om1_cal_v1 l0
%                 proved (1.7 secs)
%
% sal-bmc -i -d 35 om1_cal_v1 vaa
%   n=3, k=2, w/o LEMMA:
%   n=3, k=2, w/  LEMMA:
l0: LEMMA system_obs |- G(
    (FORALL (i:nodes): chan_empty?(cal, i, source_id)) AND
    (FORALL (i:nodes):
      (FORALL (j: relays): i /= source_id => chan_empty?(cal, i, j))) AND
    (FORALL (i:nodes):
      (FORALL (j: receivers): NOT is_relay?(i) AND NOT is_ivote?(i) =>
       chan_empty?(cal, i, j))) AND
    (FORALL (i:nodes): NOT is_receiver?(i) => chan_empty?(cal, i, ivote_id)));


%--- Tests for bounded model checker; these are non-THEOREMS  ---

% components finish eventually:
%   n=k=3: counter-ex depth 1
source_test:    THEOREM system |- G(NOT source_done);
%   n = k = 3: counter-ex depth 9
relays_test:    THEOREM system |- G(NOT FORALL (i:relays): relays_done[i]);
%   n = k = 3: counter-ex depth 46
receivers_test: THEOREM system |- G(NOT FORALL (i:receivers): receivers_done[i]);

% everyone finishes eventually:
%   n = k = 2:    counterexample depth 28
%   n = 3, k = 2: counterexample depth 33 (5.38 secs)
%   n = k = 3:    counterexample depth 47
not_all_done: THEOREM (system || observer) |- G(not_done);

END
