% SAL model of OM(1)
%
% Oral Messages 1 algorithm
% version 4
%
% Notes:
%   * static number of nodes: n=3, k=3
%   * communication is modeled through a REAL time clock module and a
%     calendar automata that keeps track of messages and delivery times
%   * attempted to minimize number of state vars
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%   * byzantine faults are modeled through the message-read mechanism
%
%   * the system of commit b4b4708 has:
%         number of system variables:    78
%         number of auxiliary variables:  8
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)
%         Lee Pike                            , Galois Inc. (2015)


om1_fault: CONTEXT =
BEGIN


%=== Nodes and IDs -----------------------------------------------===

% IDs for nodes
IDENTITY:  TYPE     = [0..6];  % 1 source, 3 relays, 3 receivers

% Static node IDs
source_id: IDENTITY = 0;

relay1_id: IDENTITY = 1;
relay2_id: IDENTITY = 2;
relay3_id: IDENTITY = 3;
RELAYS: TYPE = [1..3];
num_relays: INTEGER = 3;

receiver1_id: IDENTITY = 4;
receiver2_id: IDENTITY = 5;
receiver3_id: IDENTITY = 6;
RECEIVERS: TYPE = [4..6];

% Helper functions for identification
is_source?(i: IDENTITY):   BOOLEAN = i = source_id;
is_relay?(i: IDENTITY):    BOOLEAN = 1 <= i AND i <= 3;
is_receiver?(i: IDENTITY): BOOLEAN = 4 <= i AND i <= 6;


%=== Channels ----------------------------------------------------===

% channel IDs
%   1-3:   source -> 3 relays
%   4-6:   relay 1 -> receivers
%   7-9:   relay 2 -> receivers
%   10-12: relay 3 -> receivers
%   13-15: receiver -> self
CHANNEL: TYPE = [1..15];

% Determine if there is a channel i -> j. This is fixed at compile time.
linked?(i:IDENTITY, j:IDENTITY): BOOLEAN =
     (i = 0           AND is_relay?(j))
  OR (is_relay?(i)    AND is_receiver?(j))
  OR (is_receiver?(i) AND i = j);

% compute channel ID from the (src, dest) pair
chan(i:IDENTITY, j:IDENTITY): CHANNEL =
  IF i=0 THEN  % source -> relay chans are 1, 2, 3
    j
  ELSIF j > 3 AND i /= j THEN  % relay_i -> receiver_j chans
    4 + (i-1)*3 + (j-4)
  ELSE  % i = j is a receiver
    13 + (j-4)
  ENDIF;


%=== Time --------------------------------------------------------===

% Time is modeled by non-negative integers
% -1 is reserved as an invalid time
% -2 is reserved as an atomic "out-of-band" time
TIME: TYPE = [-2..5];
invalid_time: TIME = -1;
atomic_time: TIME = -2;
msg_delay: TIME = 1;


%=== Faults ------------------------------------------------------===

FAULTS: TYPE = ARRAY IDENTITY OF BOOLEAN;


%=== Messages and Values -----------------------------------------===

% values recieved by relays and receivers
%
% MESSAGES is modeled as an uninterpreted type to support arbitrary
% faulty values

MESSAGE: TYPE = { m: INTEGER | m >= -1 };
% some named messages
good_msg: MESSAGE = 0;
missing:  MESSAGE = -1;

% these messages are emitted by the faulty nodes
FAULT_MESSAGE: TYPE = { x: MESSAGE | x >= 0 };
uninterp_msg(x: TIME, i: IDENTITY, j: IDENTITY): FAULT_MESSAGE;

is_faulty_msg?(m: MESSAGE): BOOLEAN = m > 0;


%=== Calendar Automata -------------------------------------------===

% Calendar data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.

CALENDAR: TYPE =
  [# msg  : ARRAY CHANNEL of MESSAGE,  % contents of message
     time : ARRAY CHANNEL of TIME      % time for delivery
  #];

empty_calendar: CALENDAR =
  (# msg  := [[c:CHANNEL] missing],
     time := [[c:CHANNEL] invalid_time]
  #);


%=== Calendar API ------------------------------------------------===


msg(s: TIME, cal: CALENDAR, f: FAULTS, i:IDENTITY, j:IDENTITY): MESSAGE =
  IF f[i] THEN
    uninterp_msg(s, i, j)  % return uninterpreted message
  ELSE
    cal.msg[chan(i,j)]     % return correct message
  ENDIF;

% Helper functions for getting/setting the calendar
null?(cal: CALENDAR, c: CHANNEL): BOOLEAN =
  cal.msg[c] = missing AND cal.time[c] = invalid_time;

% Is the given time the minimum among all valid times on the calendar?
is_next_time?(cal:CALENDAR, t:TIME): BOOLEAN =
      (FORALL (c:CHANNEL): NOT null?(cal,c) => t <= cal.time[c])
  AND (EXISTS (c:CHANNEL): NOT null?(cal,c) AND t = cal.time[c]);

delivery(cal: CALENDAR, i:IDENTITY, j:IDENTITY): TIME =
  cal.time[chan(i,j)];

% Is there a regular event i -> j yet to occur at the given time?
% Returns FALSE if
%
%     A) the pair i,j has no channel between them OR
%     B) the current time is 'atomic_time'
%
node_event?(cal:CALENDAR, i:IDENTITY, j:IDENTITY, t:TIME): BOOLEAN =
      linked?(i,j)
  AND is_next_time?(cal,t)
  AND NOT null?(cal,chan(i,j))
  AND delivery(cal,i,j) = t
  AND t /= atomic_time;

% is there an event yet to occur at the given time?
event_pending?(cal:CALENDAR, t:TIME): BOOLEAN =
  (EXISTS (c:CHANNEL): cal.msg[c] /= missing AND cal.time[c] = t);

% is the atomic lock free?
atomic_free?(cal: CALENDAR): BOOLEAN = NOT event_pending?(cal, atomic_time);

% Am I in atomic mode?
i_am_atomic?(cal: CALENDAR, i: IDENTITY, t: TIME): BOOLEAN =
      EXISTS (j: IDENTITY): linked?(i,j) AND cal.time[chan(j,i)] = atomic_time
  AND t = atomic_time;

% send a message with given delay
msg_send_delta(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME, d:TIME): CALENDAR =
  cal WITH .msg[chan(i,j)]  := m
      WITH .time[chan(i,j)] := t + d;

% default msg_send function has 'msg_delay' delay
msg_send(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME): CALENDAR =
  msg_send_delta(cal, i, j, m, t, msg_delay);

% add a 'preemtive' message (or interrupt) to the calendar. This action
% prevents transitions from occuring except in the 'atomic' section of the
% calling module.
msg_send_interrupt(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  msg_send_delta(cal, i, j, good_msg, atomic_time, 0);

msg_consume(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  cal WITH .msg[chan(i,j)]  := missing
      WITH .time[chan(i,j)] := invalid_time;


%===----------------------------------------------------------------===
%       Transition System
%===----------------------------------------------------------------===

%
% The 'clock' module gives the general its message and manages the
% advance of time.
clock: MODULE =
BEGIN
    GLOBAL
      cal: CALENDAR,
      t:   TIME,
      f:   FAULTS
    INPUT
      source_done: BOOLEAN,
      relays_done: ARRAY RELAYS OF BOOLEAN,
      receivers_done: ARRAY RECEIVERS OF BOOLEAN
INITIALIZATION
    cal = empty_calendar;
    t = 0;
TRANSITION
    [
      advance_time:
        NOT is_next_time?(cal,t) --> t' IN { s:TIME | is_next_time?(cal,s) }
    []
      % allow clock to stutter once the system reaches the end of one round
      stutter:
        source_done AND
        (FORALL (i:RELAYS): relays_done[i]) AND
        (FORALL (i:RECEIVERS): receivers_done[i])
        -->  % nothing
    ]
END;

% 'source' sends a message (good_msg) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  t: TIME
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      source_broadcast:
      NOT source_done AND t = 0 -->
        cal' = LET cal1:CALENDAR = msg_send(cal,  source_id, relay1_id,
                                            good_msg, t) IN
               LET cal2:CALENDAR = msg_send(cal1, source_id, relay2_id,
                                            good_msg, t) IN
                                   msg_send(cal2, source_id, relay3_id,
                                            good_msg, t);
        source_done' = TRUE
    ]
END;


relay[i: RELAYS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT relay_done: BOOLEAN
INITIALIZATION
    relay_done = FALSE
TRANSITION
    [
      relay_broadcast:
      (NOT relay_done) AND node_event?(cal, source_id, i, t) -->
        cal' = LET m:MESSAGE     = msg(t, cal, f, source_id, i) IN
               LET cal1:CALENDAR = msg_send(cal,  i, receiver1_id, m, t) IN
               LET cal2:CALENDAR = msg_send(cal1, i, receiver2_id, m, t) IN
               LET cal3:CALENDAR = msg_send(cal2, i, receiver3_id, m, t) IN
               msg_consume(cal3, source_id, i);
        relay_done' = TRUE
    ]
END;

% Receiver modes:
%
%   - 'receiving' message buffer is not yet full
%   - 'waiting'   buffer is full, waiting to acquire atomic lock
%   - 'voting'    computing majority vote over the buffer
%   - 'done'      voting is complete and 'vote' is set with result
%
RECEIVER_MODES: TYPE = {receiving, waiting, voting, done};

receiver[p:RECEIVERS]: MODULE =
BEGIN
    GLOBAL
        cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
        vote: MESSAGE,
        receiver_done: BOOLEAN,
        counter: [0..3],
        ix: [1..4]
    LOCAL
        mode: RECEIVER_MODES,
        buffer: ARRAY RELAYS of MESSAGE,
        buffer_size: [0..num_relays],
        candidate: MESSAGE,
        pc: [0..5]
INITIALIZATION
    % outputs
    mode = receiving;
    receiver_done = FALSE;
    vote = missing;
    % locals
    buffer = [[r:RELAYS] missing];  % init empty buffer
    buffer_size = 0;
    candidate = missing;
    counter = 0;
    ix = 1;
    pc = 0;
TRANSITION
    [
      %----------------------------------------------------------------
      % Receive a message from a relay
      %
      % If buffer is full and mutex is free, then enter the vote
      % section. The mutex is freed in the 'receiver_exit' transition.
      %----------------------------------------------------------------

   ([] (i:RELAYS):

      % XXX LP: This transition rule might be strengthened so buffer[i] =
      % missing is a guard. Then it simplifies the rules. However, we need
      % to make sure that doing so doesn't cause deadlock.
      receiver_recv:
      mode = receiving AND node_event?(cal, i, p, t) -->
        buffer'[i] = IF buffer[i] = missing
                       THEN msg(t, cal, f, i, p)
                       ELSE buffer[i]             % drop message if buffer[i] is full
                     ENDIF;
        buffer_size' = IF buffer[i] = missing
                         THEN buffer_size + 1
                         ELSE buffer_size
                       ENDIF;
        cal'  = msg_consume(cal, i, p);
        mode' = IF buffer_size' = num_relays     % change modes when buffer is full
                  THEN waiting
                  ELSE receiving
                ENDIF;
      )
    []
      %----------------------------------------------------------------
      % When 'buffer' is full and the atomic lock is free, send a self-
      % message with delivery 'atomic_time'. This acquires the atomic
      % lock so the following transitions are enabled.
      %----------------------------------------------------------------

      activate_vote:
      mode = waiting AND atomic_free?(cal) -->
          cal' = msg_send_interrupt(cal, p, p);
          mode' = voting;
    []
      %----------------------------------------------------------------
      % The majority vote logic is unrolled in the following
      % transitions
      %----------------------------------------------------------------

      receiver_vote_0:
      mode = voting AND pc = 0 AND i_am_atomic?(cal, p, t) -->
        candidate' = missing;
        counter' = 0;
        ix' = 1;
        pc' = pc + 1
    []
      receiver_vote_loop:
      mode = voting AND pc > 0 AND 1 <= ix AND ix <= 3 AND i_am_atomic?(cal, p, t) -->  % 3 = max_relay_id
        candidate' = IF counter = 0
                       THEN buffer[ix]
                       ELSE candidate
                    ENDIF;
        counter'   = IF buffer[ix] = candidate
                       THEN counter+1
                     ELSIF counter = 0
                       THEN 0
                       ELSE counter-1
                     ENDIF;
        ix' = ix + 1;
        pc' = pc + 1;
    []
        receiver_exit:
        mode = voting AND pc > 0 AND ix = 4 AND i_am_atomic?(cal, p, t) -->
          cal' = msg_consume(cal, p, p);  % release the atomic lock
          vote' = candidate;
          mode' = done;
          receiver_done' = TRUE
    ]
END;


%===----------------------------------------------------------------===
%       System
%===----------------------------------------------------------------===

% asyncronous composition is used to better model message passing
system: MODULE =
        clock
     [] source
     [] (WITH OUTPUT relays_done: ARRAY RELAYS OF BOOLEAN
           ([] (x:RELAYS): RENAME relay_done TO relays_done[x] IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY RECEIVERS OF BOOLEAN
         WITH OUTPUT counters:       ARRAY RECEIVERS OF [0..3]
         WITH OUTPUT ixs:            ARRAY RECEIVERS OF [1..4]
         WITH OUTPUT votes:          ARRAY RECEIVERS of MESSAGE
           ([] (x:RECEIVERS):  RENAME vote TO votes[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN RENAME counter TO counters[x]
                               IN RENAME ix TO ixs[x]
                               IN receiver[x]));


%===----------------------------------------------------------------===
%       Syncronous Observer
%===----------------------------------------------------------------===

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: ARRAY RELAYS OF BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    votes: ARRAY RECEIVERS OF MESSAGE,
    f: FAULTS
  OUTPUT
    v_ok: BOOLEAN,
    a_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  v_ok = TRUE;
  a_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
      (FORALL (x:RECEIVERS): receivers_done[x]
         AND (NOT votes[x]=good_msg)
         AND (NOT f[source_id])
      )
        -->
        v_ok' = FALSE
  []
    no_agreement:
      (    FORALL (x:RECEIVERS): receivers_done[x]
       AND EXISTS (x,y:RECEIVERS): votes[x] /= votes[y]) -->
        a_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
      source_done AND
      (FORALL (i:RELAYS): relays_done[i]) AND
      (FORALL (r:RECEIVERS): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;


system_obs : MODULE = system || observer;


%===--------------------------------------------------------------===
%       Verification
%===--------------------------------------------------------------===

%=== Helpers ===

% Maximum fault assumption: there is at most 1 faulty node
mfa(f: FAULTS): BOOLEAN =
  FORALL (i,j: IDENTITY):
    f[i] AND f[j] => i = j;

% Validity constraint: there is at most 1 faulty node and it is not the source
% node
validity(f: FAULTS): BOOLEAN =
  mfa(f) AND NOT f[source_id];

% How many of a certain message are in the buffer?
count_in_buffer(ix: RELAYS, max: RELAYS, buffer: ARRAY RELAYS of MESSAGE, m: MESSAGE): NATURAL =
  IF ix > num_relays OR ix > max
    THEN 0
    ELSIF buffer[ix] = m
      THEN count_in_buffer(ix+1, max, buffer, m) + 1
      ELSE count_in_buffer(ix+1, max, buffer, m)
  ENDIF;

%=== Invariants ===

global_time_not_null(t: TIME): BOOLEAN = t /= -1;

monotonic_time(cal: CALENDAR, t: TIME): BOOLEAN =
 FORALL (s: TIME): is_next_time?(cal, s) => s = atomic_time OR s >= t;

missing_cal(cal: CALENDAR): BOOLEAN =
  FORALL (i: CHANNEL): cal.msg[i] = missing <=> cal.time[i] = invalid_time;

unique_atomic(cal: CALENDAR): BOOLEAN =
  FORALL (i,j: CHANNEL): cal.time[i] = -2 AND cal.time[j] = -2 => i = j;

% Proved:
% sal-inf-bmc -v 1 --delta-path -i -ice -d 1 om1_fault.sal lemma_conj
lemma_conj: LEMMA system_obs |-
  G(    monotonic_time(cal, t)
    AND global_time_not_null(t)
    AND missing_cal(cal)
    AND unique_atomic(cal)
   );

% Proved:
% sal-inf-bmc -v 1 -i -ice -d 1 -l lemma_conj om1_fault.sal fault_propagation
fault_propagation: LEMMA system_obs |-
  G(    (FORALL (j:RELAYS):                    % no faulty messages are stored here
           NOT is_faulty_msg?(cal.msg[chan(source_id, j)]))
    AND (FORALL (i:RECEIVERS):
           FORALL (j:RELAYS):
                 (is_faulty_msg?(buffer[i][j])  % faulty msg read into buffer comes
                   => f[j] OR f[source_id])     % from either faulty relay or faulty
                                                % source
             AND (is_faulty_msg?(cal.msg[chan(j, i)])
                   => f[source_id])));          % faulty msg in cal must come from
                                                % faulty source

% Proved:
% sal-inf-bmc -v 1 -i -ice -d 1 -l lemma_conj om1_fault.sal missing_buffer_size
missing_buffer_size: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i: RELAYS):
        buffer_size[r] + count_in_buffer(relay1_id, relay3_id, buffer[r], missing) = 3);

% Proved:
% sal-inf-bmc -v 1 -i -ice -d 1 -l fault_propagation om1_fault.sal one_faulty_in_buffers
one_faulty_in_buffers: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i,j: RELAYS):
            is_faulty_msg?(buffer[r][i])
        AND is_faulty_msg?(buffer[r][j])
        AND validity(f)
        => i = j);

% Main invarinant of what happens during the voting mode.
% Proved:
% sal-inf-bmc -v 1 -i -ice -d 1 -l missing_buffer_size om1_fault.sal counter_candidate_ix
counter_candidate_ix: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
    (    NOT receivers_done[r]
     AND (   (    mode[r] = receiving
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 0
             )
          OR (    (mode[r] = waiting OR mode[r] = voting)
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 0
              AND FORALL (i: RELAYS): buffer[r][i] /= missing
             )
          OR (    mode[r] = voting
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 1
              AND FORALL (i: RELAYS): buffer[r][i] /= missing
             )
          OR (    mode[r] = voting
              AND counters[r] <= count_in_buffer(relay1_id, ixs[r]-1,
                                                 buffer[r], candidate[r])
              AND ixs[r] >= 1
              AND ixs[r] <= 4
              AND pc[r] >= 1
              AND EXISTS (i: RELAYS): (buffer[r][i] = candidate[r] AND i < ixs[r])
              AND FORALL (i: RELAYS): buffer[r][i] /= missing
             )
         )
    )
    OR (    receivers_done[r]
        AND mode[r] = done
        AND ixs[r] = 4
        AND pc[r] >= 1
        AND votes[r] = candidate[r]
        AND FORALL (i: RELAYS): buffer[r][i] /= missing
       )
   );

% Proved:
% sal-inf-bmc -v 1 -i -ice -d 1 -l missing_buffer_size -l counter_candidate_ix -l one_faulty_in_buffers om1_fault.sal counter_majority
counter_majority: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      validity(f)
      => (
             (ixs[r] = 1 AND candidate[r] = missing)
          OR (ixs[r] = 2 AND counters[r] = 0)
          OR (    ixs[r] = 3
              AND (
                   (    counters[r] = 1
                    AND candidate[r] = good_msg
                    AND count_in_buffer(relay1_id, ixs[r]-1, buffer[r],
                                        candidate[r]) = 2
                   )
                   OR (
                           counters[r] = 0
                       AND count_in_buffer(relay1_id, ixs[r]-1, buffer[r],
                                           candidate[r]) <= 1
                      )
                  )
             )
          OR (ixs[r] = 4 AND candidate[r] = good_msg)
         )
   );

% Proved!
% sal-inf-bmc -v 1 -i -ice -d 1 -l counter_majority -l counter_candidate_ix -l one_faulty_in_buffers om1_fault.sal candidate_good
candidate_good: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      mode[r] = done AND validity(f) => votes[r] = good_msg);

%===  Main Theorems  ===

% Proved!
% sal-inf-bmc -v 1 -i -ice -d 1 -l candidate_good -l counter_candidate_ix om1_fault.sal validity
validity: THEOREM system_obs |- G(validity(f) => v_ok);


% ------------------------------------------------------------
% Agreement lemmas
% ------------------------------------------------------------

% XXX LP: not sure if this is useful.
% Proved
% sal-inf-bmc -i -ice -d 1 om1_fault.sal relay_chans
relay_chans: LEMMA system_obs |-
  G(FORALL (r0,r1: RECEIVERS):
      FORALL (i: RELAYS):
					 cal.msg[chan(i,r0)] = missing
        OR cal.msg[chan(i,r1)] = missing
        OR cal.msg[chan(i,r1)] = cal.msg[chan(i,r0)]);

% buffer_diff_max_one: LEMMA system_obs |-
%   G(FORALL (r0,r1: RECEIVERS):
%       FORALL (i,j : RELAYS):
%                mfa(f)
%            AND buffer[r0][i] /= buffer[r1][i]
%            AND i /= j
%            AND buffer[r0][i] /= missing
%            AND buffer[r1][i] /= missing
%         =>     buffer[r0][j] = buffer[r1][j]
%            OR  buffer[r0][j] = missing
%            OR  buffer[r1][j] = missing
%     );

% Proved assuming 'validity(f)' instead of 'mfa(f)'
% UNCOMMENT LINE BELOW FIRST: sal-inf-bmc -i -ice -d 1 -l counter_candidate_ix -l candidate_good om1_fault.sal agreement
% agreement: THEOREM system_obs |- G(validity(f) => a_ok);


% Work in progress
agreement: THEOREM system_obs |- G(mfa(f) => a_ok);



% ----------------------------------------


% system eventually finishes (at which point validity can be checked).
% Alternatively, the safety property 'not_all_done' listed below can be
% checked for counterexamples with bmc.
%
% unproved
finish: THEOREM system_obs |- F(NOT not_done);


%===--------------------------------------------------------------===
%       Tests
%===--------------------------------------------------------------===

% TESTS for bounded model checker; these are non-THEOREMS

% components finish eventually:
source_test:    THEOREM system |- G(NOT source_done);
relays_test:    THEOREM system |- G(NOT FORALL (i:RELAYS): relays_done[i]);

% counterexample at depth ?
time_test: THEOREM system |- G(t < 2);  % for msg_delay = 1 this implies we
                                        % only advance as far as the relay broadcast
% counterexample at depth ?
recv_test: THEOREM system |- G(NOT FORALL (i:RECEIVERS): receivers_done[i]);

% everyone finishes eventually:
%   true to depth ?
%   counterexample at depth ?
all_done_test: THEOREM system_obs |- G(not_done);

END
