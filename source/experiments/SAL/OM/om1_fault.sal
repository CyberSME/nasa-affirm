% SAL model of OM(1)
%
% Oral Messages 1 algorithm
% version 4
%
% Notes:
%   * static number of nodes: n=3, k=3
%   * communication is modeled through a REAL time clock module and a
%     calendar automata that keeps track of messages and delivery times
%   * attempted to minimize number of state vars
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%   * byzantine faults are modeled through the message-read mechanism
%
%   * the system of commit b4b4708 has:
%         number of system variables:    78
%         number of auxiliary variables:  8
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)
%         Lee Pike                            , Galois Inc. (2015)


om1_fault: CONTEXT =
BEGIN


%=== Nodes and IDs -----------------------------------------------===

% IDs for nodes
IDENTITY:  TYPE     = [0..6];  % 1 source, 3 relays, 3 receivers

% Static node IDs
source_id: IDENTITY = 0;

relay1_id: IDENTITY = 1;
relay2_id: IDENTITY = 2;
relay3_id: IDENTITY = 3;
RELAYS: TYPE = [1..3];
num_relays: INTEGER = 3;

receiver1_id: IDENTITY = 4;
receiver2_id: IDENTITY = 5;
receiver3_id: IDENTITY = 6;
RECEIVERS: TYPE = [4..6];

% Helper functions for identification
is_source?(i: IDENTITY):   BOOLEAN = i = source_id;
is_relay?(i: IDENTITY):    BOOLEAN = 1 <= i AND i <= 3;
is_receiver?(i: IDENTITY): BOOLEAN = 4 <= i AND i <= 6;


%=== Channels ----------------------------------------------------===

% channel IDs
%   1-3:   source -> 3 relays
%   4-6:   relay 1 -> receivers
%   7-9:   relay 2 -> receivers
%   10-12: relay 3 -> receivers
%   13-15: receiver -> self
CHANNEL: TYPE = [1..15];

% Determine if there is a channel i -> j. This is fixed at compile time.
linked?(i:IDENTITY, j:IDENTITY): BOOLEAN =
     (i = 0           AND is_relay?(j))
  OR (is_relay?(i)    AND is_receiver?(j))
  OR (is_receiver?(i) AND i = j);

% compute channel ID from the (src, dest) pair
chan(i:IDENTITY, j:IDENTITY): CHANNEL =
  IF i=0 THEN  % source -> relay chans are 1, 2, 3
    j
  ELSIF j > 3 AND i /= j THEN  % relay_i -> receiver_j chans
    4 + (i-1)*3 + (j-4)
  ELSE  % i = j is a receiver
    13 + (j-4)
  ENDIF;


%=== Time --------------------------------------------------------===

% Time is modeled by non-negative integers
% -1 is reserved as an invalid time
% -2 is reserved as an atomic "out-of-band" time
TIME: TYPE = [-2..5];
invalid_time: TIME = -1;
atomic_time: TIME = -2;
msg_delay: TIME = 1;


%=== Faults ------------------------------------------------------===

FAULTS: TYPE = ARRAY IDENTITY OF BOOLEAN;


%=== Messages and Values -----------------------------------------===

% values recieved by relays and receivers
%
% MESSAGES is modeled as an uninterpreted type to support arbitrary
% faulty values

MESSAGE: TYPE = { m: INTEGER | m >= -1 };
%MESSAGE: TYPE = { m: INTEGER | m >= -1 AND m < 2 };  % for debug
% some named messages
good_msg: MESSAGE = 0;
missing:  MESSAGE = -1;

% these messages are emitted by the faulty nodes
FAULT_MESSAGE: TYPE = { x: MESSAGE | x >= 0 };
uninterp_msg(x: TIME, i: IDENTITY, j: IDENTITY): FAULT_MESSAGE;
%uninterp_msg(x: TIME, i: IDENTITY, j: IDENTITY): FAULT_MESSAGE = 1;  % for debug

is_faulty_msg?(m: MESSAGE): BOOLEAN = m > 0;


%=== Calendar Automata -------------------------------------------===

% Calendar data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.

CALENDAR: TYPE =
  [# msg  : ARRAY CHANNEL of MESSAGE,  % contents of message
     time : ARRAY CHANNEL of TIME      % time for delivery
  #];

empty_calendar: CALENDAR =
  (# msg  := [[c:CHANNEL] missing],
     time := [[c:CHANNEL] invalid_time]
  #);


%=== Calendar API ------------------------------------------------===


msg(s: TIME, cal: CALENDAR, f: FAULTS, i:IDENTITY, j:IDENTITY): MESSAGE =
  IF f[i] THEN
    uninterp_msg(s, i, j)  % return uninterpreted message
  ELSE
    cal.msg[chan(i,j)]     % return correct message
  ENDIF;

% Helper functions for getting/setting the calendar
null?(cal: CALENDAR, c: CHANNEL): BOOLEAN =
  cal.msg[c] = missing AND cal.time[c] = invalid_time;

% Is the given time the minimum among all valid times on the calendar?
is_next_time?(cal:CALENDAR, t:TIME): BOOLEAN =
      (FORALL (c:CHANNEL): NOT null?(cal,c) => t <= cal.time[c])
  AND (EXISTS (c:CHANNEL): NOT null?(cal,c) AND t = cal.time[c]);

delivery(cal: CALENDAR, i:IDENTITY, j:IDENTITY): TIME =
  cal.time[chan(i,j)];

% Is there a regular event i -> j yet to occur at the given time?
% Returns FALSE if
%
%     A) the pair i,j has no channel between them OR
%     B) the current time is 'atomic_time'
%
node_event?(cal:CALENDAR, i:IDENTITY, j:IDENTITY, t:TIME): BOOLEAN =
      linked?(i,j)
  AND is_next_time?(cal,t)
  AND NOT null?(cal,chan(i,j))
  AND delivery(cal,i,j) = t
  AND t /= atomic_time;

% is there an event yet to occur at the given time?
event_pending?(cal:CALENDAR, t:TIME): BOOLEAN =
  (EXISTS (c:CHANNEL): cal.msg[c] /= missing AND cal.time[c] = t);

% Am I in atomic mode?
i_am_atomic?(cal: CALENDAR, i: IDENTITY, t: TIME): BOOLEAN =
      EXISTS (j: IDENTITY): linked?(i,j) AND cal.time[chan(j,i)] = atomic_time
  AND t = atomic_time;

% send a message with given delay
msg_send_delta(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME, d:TIME):
CALENDAR =
  cal WITH .msg[chan(i,j)]  := m
      WITH .time[chan(i,j)] := t + d;

% default msg_send function has 'msg_delay' delay
msg_send(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME): CALENDAR =
  msg_send_delta(cal, i, j, m, t, msg_delay);

% add a 'preemtive' message (or interrupt) to the calendar. This action
% prevents transitions from occuring except in the 'atomic' section of the
% calling module.
msg_send_interrupt(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  msg_send_delta(cal, i, j, good_msg, atomic_time, 0);

msg_consume(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  cal WITH .msg[chan(i,j)]  := missing
      WITH .time[chan(i,j)] := invalid_time;


%===----------------------------------------------------------------===
%       Transition System
%===----------------------------------------------------------------===

%
% The 'clock' module gives the general its message and manages the
% advance of time.
clock: MODULE =
BEGIN
    GLOBAL
      cal: CALENDAR,
      t:   TIME,
      f:   FAULTS
    INPUT
      source_done: BOOLEAN,
      relays_done: ARRAY RELAYS OF BOOLEAN,
      receivers_done: ARRAY RECEIVERS OF BOOLEAN
INITIALIZATION
    cal = empty_calendar;
    t = 0;
TRANSITION
    [
      advance_time:
        NOT is_next_time?(cal,t) --> t' IN { s:TIME | is_next_time?(cal,s) }
    []
      % allow clock to stutter once the system reaches the end of one round
      stutter:
        source_done AND
        (FORALL (i:RELAYS): relays_done[i]) AND
        (FORALL (i:RECEIVERS): receivers_done[i])
        -->  % nothing
    ]
END;

% 'source' sends a message (good_msg) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  t: TIME
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      source_broadcast:
      NOT source_done AND t = 0 -->
        cal' = LET cal1:CALENDAR = msg_send(cal,  source_id, relay1_id,
                                            good_msg, t) IN
               LET cal2:CALENDAR = msg_send(cal1, source_id, relay2_id,
                                            good_msg, t) IN
                                   msg_send(cal2, source_id, relay3_id,
                                            good_msg, t);
        source_done' = TRUE
    ]
END;


relay[i: RELAYS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
      relay_done: BOOLEAN,
      latch: MESSAGE
INITIALIZATION
    latch      = missing;
    relay_done = FALSE
TRANSITION
    [
      relay_broadcast:
      (NOT relay_done) AND node_event?(cal, source_id, i, t) -->
        latch' = msg(t, cal, f, source_id, i);
        cal' = LET m:MESSAGE     = msg(t, cal, f, source_id, i) IN
               LET cal1:CALENDAR = msg_send(cal,  i, receiver1_id, m, t) IN
               LET cal2:CALENDAR = msg_send(cal1, i, receiver2_id, m, t) IN
               LET cal3:CALENDAR = msg_send(cal2, i, receiver3_id, m, t) IN
               msg_consume(cal3, source_id, i);
        relay_done' = TRUE
    ]
END;

% Receiver modes:
%
%   - 'receiving' message buffer is not yet full
%   - 'voting'    buffer is full; computing majority vote over the buffer
%   - 'done'      voting is complete and 'vote' is set with result
%
RECEIVER_MODES: TYPE = {receiving, voting, done};

receiver[p:RECEIVERS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  f: FAULTS, t: TIME
    OUTPUT
        buffer: ARRAY RELAYS of MESSAGE,
        vote: MESSAGE,
        receiver_done: BOOLEAN,
        counter: [0..3],
        ix: [1..4]
    LOCAL
        mode: RECEIVER_MODES,
        buffer_size: [0..num_relays],
        candidate: MESSAGE,
        pc: [0..5]
INITIALIZATION
    % outputs
    mode = receiving;
    receiver_done = FALSE;
    vote = missing;
    % locals
    buffer = [[r:RELAYS] missing];  % init empty buffer
    buffer_size = 0;
    candidate = missing;
    counter = 0;
    ix = 1;
    pc = 0;
TRANSITION
    [
      %----------------------------------------------------------------
      % Receive a message from a relay
      %
      % When 'buffer' is full send a self- message with delivery
      % 'atomic_time'. This acquires the atomic lock so the following
      % transitions are enabled.
      %----------------------------------------------------------------

   ([] (i:RELAYS):
      receiver_recv:
      mode = receiving AND node_event?(cal, i, p, t) AND buffer[i] = missing -->
        buffer'[i]   = msg(t, cal, f, i, p);
        buffer_size' = buffer_size + 1;
        cal'         = IF buffer_size' = num_relays  % buffer is full
                          THEN LET cal1: CALENDAR = msg_consume(cal, i, p)
                               IN  msg_send_interrupt(cal1, p, p)
                          ELSE msg_consume(cal, i, p)
                       ENDIF;
        mode'        = IF buffer_size' = num_relays  % buffer is full
                         THEN voting
                         ELSE receiving
                       ENDIF;
      )
    []
      %----------------------------------------------------------------
      % drop incoming message if buffer[i] is full
      %----------------------------------------------------------------

   ([] (i:RELAYS):
      receiver_recv:
      mode = receiving AND node_event?(cal, i, p, t) AND buffer[i] /= missing -->
        cal' = msg_consume(cal, i, p);
      )
    []
      %----------------------------------------------------------------
      % The majority vote logic is unrolled in the following
      % transitions
      %----------------------------------------------------------------

      receiver_vote_0:
      mode = voting AND pc = 0 AND i_am_atomic?(cal, p, t) -->
        candidate' = missing;
        counter' = 0;
        ix' = 1;
        pc' = pc + 1
    []
      receiver_vote_loop:
      mode = voting AND pc > 0 AND 1 <= ix AND ix <= 3 AND i_am_atomic?(cal, p, t) -->  % 3 = max_relay_id
        candidate' = IF counter = 0
                       THEN buffer[ix]
                       ELSE candidate
                    ENDIF;
        counter'   = IF buffer[ix] = candidate
                       THEN counter+1
                     ELSIF counter = 0
                       THEN 0
                       ELSE counter-1
                     ENDIF;
        ix' = ix + 1;
        pc' = pc + 1;
    []
        receiver_exit:
        mode = voting AND pc > 0 AND ix = 4 AND i_am_atomic?(cal, p, t) -->
          cal' = msg_consume(cal, p, p);  % release the atomic lock
          vote' = candidate;
          mode' = done;
          receiver_done' = TRUE
    ]
END;


%===----------------------------------------------------------------===
%       System
%===----------------------------------------------------------------===

% asyncronous composition is used to better model message passing
system: MODULE =
        clock
     [] source
     [] (WITH OUTPUT relays_done: ARRAY RELAYS OF BOOLEAN
         WITH OUTPUT latches: ARRAY RELAYS OF MESSAGE
           ([] (x:RELAYS): RENAME relay_done TO relays_done[x]
                           IN RENAME latch TO latches[x]
                           IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY RECEIVERS OF BOOLEAN
         WITH OUTPUT counters:       ARRAY RECEIVERS OF [0..3]
         WITH OUTPUT ixs:            ARRAY RECEIVERS OF [1..4]
         WITH OUTPUT buffers:        ARRAY RECEIVERS of ARRAY RELAYS of MESSAGE
         WITH OUTPUT votes:          ARRAY RECEIVERS of MESSAGE
           ([] (x:RECEIVERS):  RENAME vote TO votes[x]
                               IN RENAME buffer TO buffers[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN RENAME counter TO counters[x]
                               IN RENAME ix TO ixs[x]
                               IN receiver[x]));


%===----------------------------------------------------------------===
%       Syncronous Observer
%===----------------------------------------------------------------===

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: ARRAY RELAYS OF BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    votes: ARRAY RECEIVERS OF MESSAGE,
    f: FAULTS
  OUTPUT
    v_ok: BOOLEAN,
    a_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  v_ok = TRUE;
  a_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
      (FORALL (x:RECEIVERS): receivers_done[x]
         AND (NOT votes[x]=good_msg)
         AND (NOT f[source_id])
      )
        -->
        v_ok' = FALSE
  []
    no_agreement:
      (    FORALL (x:RECEIVERS): receivers_done[x]
       AND EXISTS (x,y:RECEIVERS): votes[x] /= votes[y]) -->
        a_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
      source_done AND
      (FORALL (i:RELAYS): relays_done[i]) AND
      (FORALL (r:RECEIVERS): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;


ABSTRACT_STATE: TYPE = {a1, a2, a3, a4, a5, bad};

abstractor: MODULE =
BEGIN
  INPUT
    cal: CALENDAR,
    f: ARRAY IDENTITY OF BOOLEAN,
    source_done: BOOLEAN,
    latches: ARRAY RELAYS OF MESSAGE,
    relays_done: ARRAY RELAYS OF BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    buffers: ARRAY RECEIVERS OF ARRAY RELAYS OF MESSAGE,
    votes: ARRAY RECEIVERS OF MESSAGE
  OUTPUT
    A1, A2, A3, A4, A5: BOOLEAN
  DEFINITION

    % No messages have been sent or received yet
    A1 =     (FORALL (c: CHANNEL): null?(cal, c))
         AND NOT source_done
         AND (FORALL (i: RELAYS): NOT relays_done[i] AND latches[i] = missing)
         AND (FORALL (r: RECEIVERS): NOT receivers_done[r]
                AND votes[r] = missing
                AND (FORALL (i: RELAYS): buffers[r][i] = missing));

    % source has sent it's message
    A2 =      (FORALL (c: CHANNEL): null?(cal, c) <=> c > 3)
         AND source_done
         AND (FORALL (i: RELAYS): NOT relays_done[i] AND latches[i] = missing)
         AND (FORALL (i: RECEIVERS): NOT receivers_done[i]
                AND votes[i] = missing)
         AND (FORALL (i: RELAYS, j: RECEIVERS): buffers[j][i] = missing);

    % at least one relay is done; no receivers are done
    % XXX remove fault + latch clauses to external lemma (also A4, A5)
    A3 =     source_done
         AND (FORALL (i: RELAYS): relays_done[i] <=> latches[i] /= missing)
         AND (EXISTS (i: RELAYS): relays_done[i])
         AND (FORALL (i: RECEIVERS): NOT receivers_done[i]
                AND votes[i] = missing)
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                   (NOT relays_done[i] AND null?(cal, chan(i,j))           AND buffers[j][i] = missing)
                OR (    relays_done[i] AND cal.msg[chan(i,j)] = latches[i] AND buffers[j][i] = missing)
                OR (    relays_done[i] AND null?(cal, chan(i,j))           AND
buffers[j][i] /= missing AND (NOT f[i] => buffers[j][i] = latches[i]))
             );

    % all relays are done; at least one receiver is done
    A4 =     source_done
         AND (FORALL (i: RELAYS): relays_done[i] AND latches[i] /= missing)
         AND (EXISTS (r: RECEIVERS): receivers_done[r]
                %AND votes[r] /= missing
                AND (EXISTS (i: RELAYS): votes[r] = buffers[r][i])
                AND (FORALL (i: RELAYS): null?(cal, chan(i,r))))
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                   (cal.msg[chan(i,j)] = latches[i] AND buffers[j][i] = missing)
                OR (null?(cal, chan(i,j))           AND buffers[j][i] /= missing AND (NOT f[i] => buffers[j][i] = latches[i]))
             );

    % all nodes are done
    A5 =     source_done
         AND (FORALL (i: RELAYS): relays_done[i]
                AND latches[i] /= missing)
         AND (FORALL (r: RECEIVERS): receivers_done[r]
                %AND votes[r] /= missing
                AND (EXISTS (i: RELAYS): votes[r] = buffers[r][i]))
         AND (FORALL (i: RELAYS, j: RECEIVERS):
                null?(cal, chan(i,j)) AND buffers[j][i] /= missing AND (NOT f[i] => buffers[j][i] = latches[i]))
         AND (FORALL (c: CHANNEL): null?(cal, c));
END;


abstract_monitor: MODULE =
BEGIN
  INPUT A1, A2, A3, A4, A5: BOOLEAN
  LOCAL state: ABSTRACT_STATE
  INITIALIZATION
    state = a1
  TRANSITION
    [
      state = a1 -->
        state' = IF      A1' THEN a1
                   ELSIF A2' THEN a2
                   ELSE           bad
                   ENDIF
    []
      state = a2 -->
        state' = IF      A2' THEN a2
                   ELSIF A3' THEN a3
                   ELSE           bad
                   ENDIF
    []
      state = a3 -->
        state' = IF      A3' THEN a3
                   ELSIF A4' THEN a4
                   ELSE           bad
                   ENDIF
    []
      state = a4 -->
        state' = IF      A4' THEN a4
                   ELSIF A5' THEN a5
                   ELSE           bad
                   ENDIF
    []
      state = a5 -->
        state' = IF      A5' THEN a5
                   ELSE           bad
                   ENDIF
    []
      % state = bad
      ELSE -->
    ]
END;


system_obs : MODULE = system || observer || abstractor || abstract_monitor;


%===--------------------------------------------------------------===
%       Verification
%===--------------------------------------------------------------===


%==  Abstraction Lemmas  ==

% sal-inf-bmc -d 1 om1_fault abstract_init
abstract_init: LEMMA system_obs |- A1;

% sal-inf-bmc -i --disable-traceability -d 1 om1_fault abstract_a1
abstract_a1:   LEMMA system_obs |- G(state = a1 => A1);

% sal-inf-bmc -i --disable-traceability -d 1 om1_fault abstract_a2
abstract_a2:   LEMMA system_obs |- G(state = a2 => A2);

% sal-inf-bmc -i --disable-traceability -d 1 om1_fault abstract_a3
abstract_a3:   LEMMA system_obs |- G(state = a3 => A3);

% sal-inf-bmc -i --disable-traceability -d 1 om1_fault abstract_a4
abstract_a4:   LEMMA system_obs |- G(state = a4 => A4);

% sal-inf-bmc -i --disable-traceability -d 1 om1_fault abstract_a5
abstract_a5:   LEMMA system_obs |- G(state = a5 => A5);

% 'abstract_invt' is used to show that the abstraction is sound
%
% Proved: (using many lemmas)
% sal-inf-bmc -i -ice -d 1 -l abstract_a1 -l abstract_a2 -l abstract_a3 -l abstract_a4 -l abstract_a5 -l lemma_conj -l lemma_source -l lemma_relays -l lemma_receivers -l counter_candidate_ix om1_fault abstract_invt
abstract_invt: LEMMA system_obs |- G(state /= bad);

% sal-inf-bmc -i --disable-traceability -d 1 om1_fault abstract_all
abstract_all: LEMMA system_obs |-
  G(    (state = a1 => A1)
    AND (state = a2 => A2)
    AND (state = a3 => A3)
    AND (state = a4 => A4)
    AND (state = a5 => A5)
    AND (state /= bad));

% We'd like to prove the following lemma using the abstraction
% order of doneness states
%   1. before any relay is done, the source must be
%   2. before any receiver is done, all relays must be
%
% Proved:
% sal-inf-bmc -i -ice -d 1 -l abstract_invt om1_fault order_of_done
order_of_done: LEMMA
system_obs |-
  G(    (EXISTS (i: RELAYS): relays_done[i]) => source_done
    AND (EXISTS (r: RECEIVERS): receivers_done[r] =>
           FORALL (i: RELAYS): relays_done[i]
        )
  );


%==  Helpers  ==

% Maximum fault assumption: there is at most 1 faulty node
mfa(f: FAULTS): BOOLEAN =
  FORALL (i,j: IDENTITY):
    f[i] AND f[j] => i = j;

% Validity constraint: there is at most 1 faulty node and it is not the source
% node
validity(f: FAULTS): BOOLEAN =
  mfa(f) AND NOT f[source_id];

% How many of a certain message are in the buffer?
count_in_buffer(ix: RELAYS, max: RELAYS, buffer: ARRAY RELAYS of MESSAGE, m: MESSAGE): NATURAL =
  IF ix > num_relays OR ix > max
    THEN 0
    ELSIF buffer[ix] = m
      THEN count_in_buffer(ix+1, max, buffer, m) + 1
      ELSE count_in_buffer(ix+1, max, buffer, m)
  ENDIF;


%==  Invariants  ==

global_time_not_null(t: TIME): BOOLEAN = t /= -1;

monotonic_time(cal: CALENDAR, t: TIME): BOOLEAN =
 FORALL (s: TIME): is_next_time?(cal, s) => s = atomic_time OR s >= t;

missing_cal(cal: CALENDAR): BOOLEAN =
  FORALL (i: CHANNEL): cal.msg[i] = missing <=> cal.time[i] = invalid_time;

unique_atomic(cal: CALENDAR): BOOLEAN =
  FORALL (i,j: CHANNEL): cal.time[i] = -2 AND cal.time[j] = -2 => i = j;

% node specific invariants

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l lemma_conj om1_fault lemma_source
lemma_source: LEMMA
system_obs |-
  G(NOT source_done => (FORALL (i: RELAYS): null?(cal, chan(source_id, i))));

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l lemma_conj om1_fault lemma_relays
lemma_relays: LEMMA
system_obs |-
  G(FORALL(i: RELAYS):
          (NOT relays_done[i] => FORALL (r: RECEIVERS):
                                   null?(cal, chan(i, r)) AND buffers[r][i] = missing)
      AND (    relays_done[i] => FORALL (r: RECEIVERS):
                                      (null?(cal, chan(i, r))
                                       AND buffers[r][i] /= missing)
                                   OR (NOT null?(cal, chan(i, r))
                                       AND buffers[r][i] = missing))
  );

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l lemma_conj om1_fault lemma_receivers
lemma_receivers: LEMMA
system_obs |-
  G(FORALL(r: RECEIVERS):
          (receivers_done[r] <=> mode[r] = done)
      AND (receivers_done[r] => null?(cal, chan(r, r)))
      % AND (FORALL (i: RELAYS): NOT relays_done[i] => NOT receivers_done[r]
      %                                                AND null?(cal, chan(r, r)))
      % AND (receivers_done[r] => FORALL (i: RELAYS): null?(cal, chan(i, r)))
  );

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 om1_fault.sal lemma_conj
lemma_conj: LEMMA system_obs |-
  G(    monotonic_time(cal, t)
    AND global_time_not_null(t)
    AND missing_cal(cal)
    AND unique_atomic(cal)
   );

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l lemma_conj om1_fault.sal fault_propagation
fault_propagation: LEMMA system_obs |-
  G(    (FORALL (j:RELAYS):                    % no faulty messages are stored here
           NOT is_faulty_msg?(cal.msg[chan(source_id, j)]))
    AND (FORALL (i:RECEIVERS):
           FORALL (j:RELAYS):
                 (is_faulty_msg?(buffers[i][j])  % faulty msg read into buffer comes
                   => f[j] OR f[source_id])     % from either faulty relay or faulty
                                                % source
             AND (is_faulty_msg?(cal.msg[chan(j, i)])
                   => f[source_id])));          % faulty msg in cal must come from
                                                % faulty source

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l lemma_conj om1_fault.sal missing_buffer_size
missing_buffer_size: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i: RELAYS):
        buffer_size[r] + count_in_buffer(relay1_id, relay3_id, buffers[r], missing) = 3);

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l fault_propagation om1_fault.sal one_faulty_in_buffers
one_faulty_in_buffers: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i,j: RELAYS):
            is_faulty_msg?(buffers[r][i])
        AND is_faulty_msg?(buffers[r][j])
        AND validity(f)
        => i = j);

% Main invarinant of what happens during the voting mode.
% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l missing_buffer_size om1_fault.sal counter_candidate_ix
counter_candidate_ix: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
    (    NOT receivers_done[r]
     AND (   (    mode[r] = receiving
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 0
              AND buffer_size[r] < 3
             )
          OR (    mode[r] = voting
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 0
              AND buffer_size[r] = 3
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
          OR (    mode[r] = voting
              AND counters[r] = 0
              AND ixs[r] = 1
              AND pc[r] = 1
              AND buffer_size[r] = 3
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
          OR (    mode[r] = voting
              AND counters[r] <= count_in_buffer(relay1_id, ixs[r]-1,
                                                 buffers[r], candidate[r])
              AND ixs[r] >= 1
              AND ixs[r] <= 4
              AND pc[r] >= 1
              AND EXISTS (i: RELAYS): (buffers[r][i] = candidate[r] AND i < ixs[r])
              AND buffer_size[r] = 3
              AND FORALL (i: RELAYS): buffers[r][i] /= missing
             )
         )
    )
    OR (    receivers_done[r]
        AND mode[r] = done
        AND ixs[r] = 4
        AND pc[r] >= 1
        AND votes[r] = candidate[r]
        AND buffer_size[r] = 3
        AND FORALL (i: RELAYS): buffers[r][i] /= missing
       )
   );

% Proved:
% sal-inf-bmc -i --disable-traceability -d 1 -l missing_buffer_size -l counter_candidate_ix -l one_faulty_in_buffers om1_fault.sal counter_majority
counter_majority: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      validity(f)
      => (
             (ixs[r] = 1 AND candidate[r] = missing)
          OR (ixs[r] = 2 AND counters[r] = 0)
          OR (    ixs[r] = 3
              AND (
                   (    counters[r] = 1
                    AND candidate[r] = good_msg
                    AND count_in_buffer(relay1_id, ixs[r]-1, buffers[r],
                                        candidate[r]) = 2
                   )
                   OR (
                           counters[r] = 0
                       AND count_in_buffer(relay1_id, ixs[r]-1, buffers[r],
                                           candidate[r]) <= 1
                      )
                  )
             )
          OR (ixs[r] = 4 AND candidate[r] = good_msg)
         )
   );

% Proved!
% sal-inf-bmc -i --disable-traceability -d 1 -l counter_majority -l counter_candidate_ix -l one_faulty_in_buffers om1_fault.sal candidate_good
candidate_good: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      mode[r] = done AND validity(f) => votes[r] = good_msg);

%==   Main Theorems   ==

% Proved!
% sal-inf-bmc -i --disable-traceability -d 1 -l candidate_good -l counter_candidate_ix om1_fault.sal validity
validity: THEOREM system_obs |- G(validity(f) => v_ok);


%===----------------------------------------------------------
%     Agreement lemmas
%===----------------------------------------------------------


%==  Experiments  ==

% BJ: not clear if this lemma is useful
%
% This is meant to be the alternative case to the one proven in
% 'relay_buffers' where here the source is explicitly faulty.
%
% Unproven
% XXX sal-inf-bmc -i --disable-traceability -d 1 om1_fault.sal source_fault_in_buffer
source_fault_in_buffer: LEMMA system_obs |-
  G(FORALL (i: RELAYS):
         f[source_id]
         AND NOT f[i]
         AND (FORALL (r: RECEIVERS): receivers_done[r])
      =>
         (FORALL (r0,r1: RECEIVERS): buffers[r0][i] = buffers[r1][i])
   );

% BJ: not clear if this lemma is useful
% Proved
% sal-inf-bmc -i --disable-traceability -d 1 -l lemma_conj om1_fault.sal relay_done
relay_done: LEMMA system_obs |-
  G(FORALL (i: RELAYS):
         relays_done[i]
      => (FORALL (r: RECEIVERS):
            (cal.msg[chan(i,r)] /= missing AND cal.time[chan(i,r)] >= t)
            OR (null?(cal, chan(i,r)) AND buffers[r][i] /= missing))
   );

%==  END Experiments  ==



% Proved!
% sal-inf-bmc -i --disable-traceability -d 1 -l fault_propagation om1_fault.sal fault_origin
fault_origin: LEMMA system_obs |-
  G(FORALL (r: RECEIVERS):
      FORALL (i,j: RELAYS):
            is_faulty_msg?(buffers[r][i])
        AND is_faulty_msg?(buffers[r][j])
        AND mfa(f)
        => f[source_id] OR i = j);

% The message sent by relay 'i' is consistent across all receivers, regardless
% of whether 'i' is faulty (faults show up upon reading the message from the
% channel).
%
% XXX LP: not sure if this is useful.
% Proved
% sal-inf-bmc -i --disable-traceability -d 1 om1_fault.sal relay_chans
relay_chans: LEMMA system_obs |-
  G(FORALL (r0,r1: RECEIVERS):
      FORALL (i: RELAYS):
           cal.msg[chan(i,r0)] = missing
        OR cal.msg[chan(i,r1)] = missing
        OR cal.msg[chan(i,r1)] = cal.msg[chan(i,r0)]);

% Assume source and relay 'i' are *not* faulty. Whenever two receivers have
% obtained values from relay 'i', they are equal.
%
% BJ: I think this trivially follows from 'fault_propagation' b/c if source and
% relay are good, the only possible value in buffer[-][i] is 'good' and, of
% course, good = good.
%
% BJ: trying to prove the weaker version, I think it requires a latch at the
% relay to save the sent value...
%
% Unproven:
% XXX sal-inf-bmc -i --disable-traceability -d 1 -l fault_propagation om1_fault.sal relay_buffers
relay_buffers: LEMMA system_obs |-
  G(FORALL (r0,r1: RECEIVERS):
      FORALL (i: RELAYS):
        (   buffers[r0][i] /= missing
        AND buffers[r1][i] /= missing
        AND NOT f[i] =>
          buffers[r0][i] = buffers[r1][i])
  );

% Lemma relating values that appear on the calendar and in the buffers. This
% requires adding a history variable tracking 'cal.msg'. Here, the history
% variable is called 'cal.hist'
%
% Proved 2-inductive
% TODO: refine to an inductive lemma
% XXX sal-inf-bmc -i --disable-traceability -d 2 om1_fault.sal relay_to_recv_step
%
% relay_to_recv_step: LEMMA system_obs |-
%   G(FORALL (r: RECEIVERS, i: RELAYS):
%       NOT f[i] =>
%         (cal.msg[chan(i,r)] /= missing AND buffers[r][i] = missing =>
%          X(buffers[r][i] = cal.hist[chan(i,r)] OR buffers[r][i] = missing)));

% buffer_diff_max_one: LEMMA system_obs |-
%   G(FORALL (r0,r1: RECEIVERS):
%       FORALL (i,j : RELAYS):
%                mfa(f)
%            AND buffers[r0][i] /= buffers[r1][i]
%            AND i /= j
%            AND buffers[r0][i] /= missing
%            AND buffers[r1][i] /= missing
%         =>     buffers[r0][j] = buffers[r1][j]
%            OR  buffers[r0][j] = missing
%            OR  buffers[r1][j] = missing
%     );

% Proved assuming 'validity(f)' instead of 'mfa(f)'
% RUN sal-inf-bmc -i --disable-traceability -d 1 -l counter_candidate_ix -l candidate_good om1_fault.sal agreement
% UNCOMMENT LINE BELOW:
% agreement: THEOREM system_obs |- G(validity(f) => a_ok);


% Work in progress
agreement: THEOREM system_obs |- G(mfa(f) => a_ok);



% ----------------------------------------


% system eventually finishes (at which point validity can be checked).
% Alternatively, the safety property 'not_all_done' listed below can be
% checked for counterexamples with bmc.
%
% unproved
finish: THEOREM system_obs |- F(NOT not_done);


%===--------------------------------------------------------------===
%       Tests
%===--------------------------------------------------------------===

% TESTS for bounded model checker; these are non-THEOREMS

% components finish eventually:
source_test:    THEOREM system |- G(NOT source_done);
relays_test:    THEOREM system |- G(NOT FORALL (i:RELAYS): relays_done[i]);

% counterexample at depth ?
time_test: THEOREM system |- G(t < 2);  % for msg_delay = 1 this implies we
                                        % only advance as far as the relay broadcast
% counterexample at depth ?
recv_test: THEOREM system |- G(NOT FORALL (i:RECEIVERS): receivers_done[i]);

% everyone finishes eventually:
%   true to depth ?
%   counterexample at depth ?
all_done_test: THEOREM system_obs |- G(not_done);

END
