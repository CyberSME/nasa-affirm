% SAL model of OM(1)
%
% Oral Messages 1 algorithm
% version 3b
%
% Notes:
%   * communication is modeled through a REAL time clock module and a
%     calendar automata that keeps track of messages and delivery times
%   * all nodes in 'system' are composed asynchronously
%   * main properties are specified using synchronous observer 'observer'
%   * no faults are modeled
%
% Author: Benjamin F Jones <bjones@galois.com>, Galois Inc. (2015)


%--- Parameters -----------------------------------------------------

% These parameters control the size of the system. Basic verification is
% tractable when n <= 3 and k <= 2.
%
% n: NATURAL = 3;  % num relays
% k: NATURAL = 2;  % num receivers

om1_cal_v3{; n: NATURAL, k: NATURAL}: CONTEXT =
BEGIN


%--- Nodes and IDs --------------------------------------------------

% IDs for nodes
IDENTITY:  TYPE     = [0..n+k+1];  % n relays, k receivers, 1 source, 1 vote procedure
num_nodes: NATURAL  = n+k+2;

source_id: IDENTITY = 0;
ivote_id:  IDENTITY = n+k+1;

% Flat array for pairs of nodes
num_pairs: NATURAL  = num_nodes*num_nodes;
PAIRS: TYPE = [0..num_pairs-1];

% encode pairs of bounded integers
mkPair(i: IDENTITY, j:IDENTITY): PAIRS = i*num_nodes + j;
unPair(p: PAIRS): [IDENTITY, IDENTITY] = (p DIV num_nodes, p MOD num_nodes);

% IDs for relays
relay_id_min: IDENTITY = 1;
relay_id_max: IDENTITY = n;
RELAYS: TYPE = [1..n];

% IDs for receivers
receiver_id_min: IDENTITY = n+1;
receiver_id_max: IDENTITY = n+k;
RECEIVERS: TYPE = [n+1..n+k];

% Helper functions for identification
is_source?(i: IDENTITY):   BOOLEAN = i = source_id;
is_relay?(i: IDENTITY):    BOOLEAN = relay_id_min <= i AND i <= relay_id_max;
is_receiver?(i: IDENTITY): BOOLEAN = receiver_id_min <= i AND i <= receiver_id_max;
is_ivote?(i:IDENTITY):     BOOLEAN = i = ivote_id;


%--- Messages and Values --------------------------------------------

% values recieved by relays and receivers
MESSAGE: TYPE = [0..n+2];
missing_v: MESSAGE = 0;    % no message present
correct_v: MESSAGE = n+1;  % intended message from source
recv_msg:  MESSAGE = n+2;  % special message used only by receivers

relay_vals: TYPE = ARRAY RELAYS OF MESSAGE;
recv_vals:  TYPE = ARRAY RECEIVERS OF MESSAGE;

% call stacks for 'ivote'
stack: TYPE = ARRAY RECEIVERS OF relay_vals;

% Time is modeled by non-negative integers 
% -1 is reserved as an invalid time
% -2 is reserved as an atomic "out-of-band" time
TIME: TYPE = [-2..10];
invalid_time: TIME = -1;
atomic_time: TIME = -2;
msg_delay: TIME = 1;


%
%--- Calendar Automata ----------------------------------------------
%
% Calendar data structure for communication between nodes. The structure
% allows for at most 1 message to be sent from any node to any other
% at a given time.
%
CALENDAR: TYPE =
  [# msg      : ARRAY PAIRS of MESSAGE,  % contents of message
     delivery : ARRAY PAIRS of TIME      % time for delivery
  #];

empty_calendar: CALENDAR =
  (# msg      := [[ij:PAIRS] missing_v],
     delivery := [[ij:PAIRS] invalid_time]
  #);

null?(cal:CALENDAR, i:IDENTITY, j:IDENTITY): BOOLEAN =
  cal.msg[mkPair(i,j)] = missing_v           AND
  cal.delivery[mkPair(i,j)] = invalid_time;

% Helper functions for getting/setting the calendar
full?(cal: CALENDAR, i:IDENTITY, j:IDENTITY): BOOLEAN =
  cal.msg[mkPair(i,j)] /= missing_v;
msg(cal: CALENDAR, i:IDENTITY, j:IDENTITY): MESSAGE =
  cal.msg[mkPair(i,j)];
delivery(cal: CALENDAR, i:IDENTITY, j:IDENTITY): TIME =
  cal.delivery[mkPair(i,j)];

% is there an event i -> j yet to occur at the current time?
node_event?(cal:CALENDAR, i:IDENTITY, j:IDENTITY, t:TIME): BOOLEAN =
  full?(cal,i,j) AND delivery(cal,i,j) = t;

% is there an event yet to occur at the current time?
is_yet_event?(cal:CALENDAR, t:TIME): BOOLEAN =
  (EXISTS (i,j:IDENTITY):
      node_event?(cal, i, j, t));

% Return the time of the next scheduled event, returns 'invalid_time' in case
% the calendar is empty.

is_next_time(cal:CALENDAR, t:TIME): BOOLEAN =
  (FORALL (i,j:IDENTITY): full?(cal,i,j) => t <= delivery(cal,i,j)) AND
  (EXISTS (i,j:IDENTITY): full?(cal,i,j) AND t = delivery(cal,i,j));

% send a message with given delay
msg_send_delta(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME, d:TIME): CALENDAR =
  cal WITH .msg[mkPair(i,j)]      := m
      WITH .delivery[mkPair(i,j)] := t + d;

% default msg_send function has 'msg_delay' delay
msg_send(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME): CALENDAR =
  msg_send_delta(cal,i,j,m,t,msg_delay);

% same as 'msg_send', but with no message delay
msg_send_instant(cal: CALENDAR, i: IDENTITY, j:IDENTITY, m:MESSAGE, t:TIME): CALENDAR =
  msg_send_delta(cal,i,j,m,t,0);

msg_consume(cal: CALENDAR, i: IDENTITY, j:IDENTITY): CALENDAR =
  cal WITH .msg[mkPair(i,j)] := missing_v;

% Broadcast a message from the source to all the relays
msg_bcast_relays(cal: CALENDAR, m: MESSAGE, t:TIME): CALENDAR =
  LET isr:[PAIRS->BOOLEAN] = LAMBDA (p:PAIRS): is_source?(unPair(p).1) AND is_relay?(unPair(p).2) IN
    cal WITH .msg   := [[p:PAIRS] IF isr(p) THEN m    ELSE cal.msg[p] ENDIF]
        WITH .delivery := [[p:PAIRS] IF isr(p) THEN t + msg_delay ELSE cal.delivery[p] ENDIF];

% Broadcast a message from relay 'r' to all receivers
msg_bcast_receivers(cal: CALENDAR, m: MESSAGE, r:RELAYS, t:TIME): CALENDAR =
  LET irr:[PAIRS->BOOLEAN] = LAMBDA (p:PAIRS): r = unPair(p).1 AND is_receiver?(unPair(p).2) IN
    cal WITH .msg   := [[p:PAIRS] IF irr(p) THEN m    ELSE cal.msg[p] ENDIF]
        WITH .delivery := [[p:PAIRS] IF irr(p) THEN t + msg_delay ELSE cal.delivery[p] ENDIF];

%----------------------------------------------------------------------
% State Machine
%----------------------------------------------------------------------

% Notes:
%
% 'source_done', 'relays_done', etc... are for debugging and verification
%

%
% The 'controller' module gives the general its message and manages the
% advance of time.
controller: MODULE =
BEGIN
    GLOBAL
      cal: CALENDAR,
      t:   TIME,
      ivote_stack: stack
    INPUT
      source_done: BOOLEAN,
      relays_done: ARRAY RELAYS OF BOOLEAN,
      receivers_done: ARRAY RECEIVERS OF BOOLEAN
    OUTPUT
      s_in: MESSAGE  % message value for source to send
INITIALIZATION
    cal = empty_calendar;
    t = 0;
    s_in = correct_v;
    ivote_stack = [[p:RECEIVERS] [[i:RELAYS] missing_v]]
TRANSITION
    [
      advance_time:
        NOT is_yet_event?(cal, t) --> t' IN { s:TIME | is_next_time(cal,s) }
      []
        ELSE -->
    ]
END;

% 'source' sends a message (s_in) to all relays
source: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT s_in: MESSAGE, t: TIME
    OUTPUT source_done: BOOLEAN
INITIALIZATION
    source_done = FALSE;
TRANSITION
    [
      source_broadcast:
      NOT source_done -->
        cal' = msg_bcast_relays(cal, s_in, t);
        source_done' = TRUE
    ]
END;

relay[i: RELAYS]: MODULE =
BEGIN
    GLOBAL cal: CALENDAR
    INPUT  t: TIME
    OUTPUT relay_done: BOOLEAN
INITIALIZATION
    relay_done = FALSE
TRANSITION
    [
      relay_broadcast:
      (NOT relay_done) AND node_event?(cal, source_id, i, t) -->
        % broadcast message to receivers and consume in one step
        cal' = LET m:MESSAGE = msg(cal, source_id, i) IN
               LET cal1:CALENDAR = msg_bcast_receivers(cal, m, i, t) IN
               msg_consume(cal1, source_id, i);
        relay_done' = TRUE
    ]
END;

% wait_relay means waiting for all relays to send their messages
% wait_vote  means waiting on the ivote machine to return an answer
% done       means vote has been computed
receiver_modes: TYPE = {wait_relay, wait_vote, done};

receiver[p:RECEIVERS]: MODULE =
BEGIN
    GLOBAL
        cal: CALENDAR,
        ivote_stack: stack
    INPUT
        t: TIME
    OUTPUT
        mode: receiver_modes,
        vote: MESSAGE,
        receiver_done: BOOLEAN
INITIALIZATION
    mode = wait_relay;
    receiver_done = FALSE;
    vote = missing_v
TRANSITION
    [
      % rec'v message from relay
      ([] (i:RELAYS):
        receiver_recv:
        mode = wait_relay AND node_event?(cal, i, p, t) -->
          ivote_stack'[p][i] = msg(cal, i, p);
          % check if the ivote_stack if full and send ourself a reminder to
          % take the next step if so
          cal' = IF (FORALL (i:RELAYS): ivote_stack'[p][i] /= missing_v) THEN
                   LET cal1:CALENDAR = msg_send_instant(cal, p, p, recv_msg, t) IN
                   msg_consume(cal1, i, p)
                 ELSE
                   msg_consume(cal, i, p)
                 ENDIF;
      )
    []
      % call ivote' when incoming array is complete
      % TODO: model how the Tower code determines the array is complete
      receiver_call_ivote:
      mode = wait_relay AND node_event?(cal, p, p, t) -->
        % add event with delay 0
        cal'  = LET cal1:CALENDAR = msg_consume(cal, p, p) IN
                  msg_send_instant(cal1, p, ivote_id, missing_v, t);
        mode' = wait_vote
    []
      % collect return value from 'ivote'
      receiver_return_ivote:
      mode = wait_vote AND node_event?(cal, ivote_id, p, t) -->
        vote' = msg(cal, ivote_id, p);
        cal'  = msg_consume(cal, ivote_id, p);
        mode' = done;
        receiver_done' = TRUE  % TODO: no need for two done modes
    ]
END;


%----------------------------------------------------------------------
% Vote Count
%----------------------------------------------------------------------

candidate_bound: TYPE = MESSAGE;
counter_bound: TYPE = IDENTITY;
ivote_pc_range: TYPE = [0..100];  % ??? compute at compile time
ivote_input_size: INTEGER = n;
ivote_ix_range: TYPE = [0..ivote_input_size];

ivote: MODULE =
BEGIN
    GLOBAL cal : CALENDAR
    INPUT  ivote_stack: stack, t: TIME
    LOCAL
      % ivory state
      candidate: MESSAGE,        % vars declared local in 'ivote'
      counter: ivote_ix_range,
      arr: relay_vals,
      % aux state
      ivote_pc: ivote_pc_range,  % pc for 'ivote'
      ix: ivote_ix_range         % loop counter
    OUTPUT
      caller : RECEIVERS,   % corresponds to current caller
      ivote_busy : BOOLEAN  % busy counting?
    DEFINITION
      arr = ivote_stack[caller]
INITIALIZATION
    ivote_pc = 0;
    ivote_busy = FALSE
TRANSITION
    [
        % receiver 'j' calls ivote
        ([] (j: RECEIVERS):
          ivote_called:
          (NOT ivote_busy) AND node_event?(cal, j, ivote_id, t) -->
            caller' = j;
            ivote_pc' = 0;
            ivote_busy' = TRUE
            % ignore the msg, consume it when vote is computed
        )
    []
        ivote_pc_0:
        ivote_busy AND ivote_pc = 0 --> candidate' = 0; ivote_pc' = ivote_pc + 1
    []
        ivote_pc_1:
        ivote_busy AND ivote_pc = 1 --> counter' = 0;   ivote_pc' = ivote_pc + 1
    []
        ivote_pc_2:
        ivote_busy AND ivote_pc = 2 --> ix' = 0;        ivote_pc' = ivote_pc + 1
    []
        ivote_loop:
        ivote_busy AND ivote_pc > 2 AND 0 <= ix AND ix < ivote_input_size -->
          candidate' = IF arr[ix]=candidate
                         THEN candidate
                       ELSIF counter=0
                         THEN arr[ix]
                       ELSE candidate ENDIF;
          counter'   = IF arr[ix]=candidate
                         THEN counter+1
                       ELSIF counter=0
                         THEN 0
                       ELSE counter-1 ENDIF;
          ix' = ix + 1;
          ivote_pc' = ivote_pc + 1
    []
        ivote_return:
        ivote_busy AND ivote_pc > 2 AND ix = ivote_input_size -->
          cal' = LET cal1:CALENDAR = msg_consume(cal, caller, ivote_id) IN
                 msg_send(cal1, ivote_id, caller, candidate, t);
          ivote_busy' = FALSE
    ]
END;


%----------------------------------------------------------------------
% System
%----------------------------------------------------------------------

% asyncronous composition is used to better model message passing
system: MODULE =
   controller
     [] ivote
     [] source
     [] (WITH OUTPUT relays_done: ARRAY RELAYS OF BOOLEAN
           ([] (x:RELAYS): RENAME relay_done TO relays_done[x] IN relay[x]))
     [] (WITH OUTPUT receivers_done: ARRAY RECEIVERS OF BOOLEAN
         WITH OUTPUT receiver_mode: ARRAY RECEIVERS OF receiver_modes
         WITH OUTPUT votes: recv_vals
           ([] (x:RECEIVERS):  RENAME vote TO votes[x]
                               IN RENAME mode TO receiver_mode[x]
                               IN RENAME receiver_done TO receivers_done[x]
                               IN receiver[x]));


%----------------------------------------------------------------------
% Syncronous Observer
%----------------------------------------------------------------------

% Alternative to specifying THEOREMs using LTL is the
% synchronous observer for 'validity' and 'agreement'
observer: MODULE =
BEGIN
  INPUT
    source_done: BOOLEAN,
    relays_done: ARRAY RELAYS OF BOOLEAN,
    receivers_done: ARRAY RECEIVERS OF BOOLEAN,
    votes: recv_vals
  OUTPUT
    vaa_ok: BOOLEAN,
    not_done: BOOLEAN
INITIALIZATION
  vaa_ok = TRUE;
  not_done = TRUE
TRANSITION
  [
    no_validity:
      (FORALL (x:RECEIVERS): receivers_done[x]) AND
      (NOT (FORALL (x:RECEIVERS): votes[x]=correct_v)) -->
        vaa_ok' = FALSE
  []
    no_agreement:
      (FORALL (x:RECEIVERS): receivers_done[x]) AND
      (NOT (FORALL (x,y:RECEIVERS): votes[x]=votes[y])) -->
        vaa_ok' = FALSE
  []
    % For the test THEOREMS below
    all_done:
      source_done AND
      (FORALL (i:RELAYS): relays_done[i]) AND
      (FORALL (r:RECEIVERS): receivers_done[r]) -->
        not_done' = FALSE
  []
    % prevent deadlock of the observer
    ELSE -->
  ]
END;

system_obs : MODULE = system || observer;


%--------------------------------------------------------------------
%  Verification
%--------------------------------------------------------------------

%---  Main Theorems  ---

% system eventually finishes (at which point vaa can be checked).
% Alternatively, the safety property 'not_all_done' listed below can be
% checked for counterexamples with bmc.
finish: THEOREM system_obs |- F(NOT not_done);

% validity and agreement hold when the system is "done"
vaa: THEOREM system_obs |- G(vaa_ok);


%--- Invariants ---

% unused channels are empty:
l0: LEMMA system_obs |- G(
    (FORALL (i:IDENTITY): null?(cal, i, source_id)) AND
    (FORALL (i:IDENTITY):
      (FORALL (j: RELAYS): i /= source_id => null?(cal, i, j))) AND
    (FORALL (i:IDENTITY):
      (FORALL (j: RECEIVERS): i /= j AND NOT is_relay?(i) AND NOT is_ivote?(i) =>
        null?(cal, i, j))) AND
    (FORALL (i:IDENTITY): NOT is_receiver?(i) => null?(cal, i, ivote_id)));


%--- Tests for bounded model checker; these are non-THEOREMS  ---

% components finish eventually:
source_test:    THEOREM system |- G(NOT source_done);
relays_test:    THEOREM system |- G(NOT FORALL (i:RELAYS): relays_done[i]);
receivers_test: THEOREM system |- G(NOT FORALL (i:RECEIVERS): receivers_done[i]);
%
time_test: THEOREM system |- G(t < 1);  % for msg_delay = 1 this implies we
                                         % advance to the receivers
% test to see if ivote is ever called
ivote_test: THEOREM system |- G(NOT ivote_busy);

% everyone finishes eventually:
not_all_done: THEOREM system_obs |- G(not_done);

END
