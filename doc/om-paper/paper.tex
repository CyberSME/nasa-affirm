\documentclass{IEEEtran/IEEEtran}

\usepackage{ifthen}
\usepackage{xcolor}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newboolean{submission}  %set to true for the submission version
\setboolean{submission}{false}
%\setboolean{submission}{true}
\ifthenelse
{\boolean{submission}}
{ %
  \newcommand{\lee}[1]{ } %
  \newcommand{\ben}[1]{ } %
  % Put your own TODO macros here and below
} %hide todo
{ %
  \newcommand{\lee}[1]{ {\color{blue}$<$lee: #1$>$} } %
  \newcommand{\ben}[1]{ {\color{purple}$<$ben: #1$>$} } %
  \usepackage{hyperref} %
  \usepackage[inline]{showlabels} %
}


\begin{document}

\title{Towards Systematic Specification and Verification of Fault-Tolerant Protocols}
\author{Ben and Lee}


\maketitle


\begin{abstract}
  Some abstract.
\end{abstract}

\section{Introduction}

Fault-tolerant distributed systems are essential to life-critical systems, like avionics. Consequently, this class of systems demand high-assurance of correct design and implementation. Formal verification can be used to prove correctness.

There is substantial literature on verifying fault-tolerant distributed systems~\cite{}. Some of this work uses mechanical theorem-proving~\cite{}. Two problems with mechanical verification are that it requires specialized expertise and it is labor intensive. In contrast, model-checking is automated but has limited scalability. To address scalability, abstractions and optimizations are employed, both of which lead to problems. Verification abstractions are often ad-hoc and system-specific. For example, to model a node that can broadcast the values $\{0, 1\}$, or no value if when faulty, one might define an enumerated type of broadcast values sent such as

$$\{0, 1, NONE\}$$

However, the enumeration conflates environment artifacts (i.e., faults) and system artifacts. Conflating them makes formal model-to-code correspondence more difficult to achieve. An example of a verification optimization is to model message passing as shared state between nodes. While these optimizations might be safe under particular assumptions, they can lead to unsound models when a system or its environment is modified.

Our contributions combine a number of ideas in the formal verification literature to build scalable, generic formal models of fault-tolerant distributed systems.

We describe a generic formal model for fault-tolerant distributed systems that aims to reduce the need for ad-hoc verification abstractions and optimizations while maintaining scalability in Section~\ref{sec:model}. The model combines several formalisms from the literature to efficiently but systematically model and verify a broad class of systems. The model extends \emph{calendar automata}, originally developed by Dutertre and Sorea~\cite{Dutertre-Sorea}. A calendar automata is a model inspired by discrete-event simulation, used in testing real-time systems~\cite{}.  Calendar automata have previously been used to verify bounded asynchronous systems~\cite{}; here we verify a synchronous system.

The model also employs \emph{synchronous observers}~\cite{}. Synchronous observers are a modeling abstraction in which an ``observer'' actor is synchronously composed with the system under verification. We use synchronous observers to impose fault model constraints on the system. Doing so makes the fault-model compositional with the system and easy to modify. We also use synchronous observers to observe safety properties, eliding the need for complex linear temporal logic specifications. Finally, we use an \emph{abstract state machine}~\cite{}, also composed with the system under verification using synchronous observation. The abstract state machine simplifies discovering invariants and debugging counterexamples.

We demonstrate the model with an extended case-study, verifying the Oral Messages (1) protocol (OM(1))~\cite{}. While our model is more detailed---it explicitly models channels---and also more general---it allows bounded asynchrony between nodes---it is the most scalable model-checking verification of the protocol.

\lee{finish intro...}

 %% Timed automata are an alternative to the \emph{timed automata} formalism~\cite{}, as implemented in model-checkers like UPPAAL~\cite{} and Kronos~\cite{}.


% ------------------------------------------------------------
\section{Formal Model}\label{sec:model}
Here we describe our formal model specialized for fault-tolerant distributed systems. There are three principal abstractions we describe: calendar automata, synchronous observers, and abstract state machines; we describe each below.

\subsection{Calendar Automata}\label{sec:calendar}
\emph{Timed automata} are specialized formalisms for verifying real-time systems~\cite{}. Time automata assume the existence of continuously-varying real-valued variables, known as \emph{real-time clocks} in a solver. While successful timed automata model-checkers exist, they are specialized for verifying real-time systems in which the only infinite-valued variables are the real-time clocks. Modern general-purpose model-checkers like \lee{name some} use SMT solvers for general infinite-state system verification that is not limited to real-time clocks.

However, real-time system verification in general-purpose model-checkers requires an explicit formalism of real-time progression. Trying to encode real-time clocks directly is difficult; in particular, one must avoid Zeno's paradox in which no progress is made because state transitions simply update real-valued variables by an infinitesimally small amount~\cite{bruno,lamport}. To avoid this problem, Dutetre and Sorea developed \emph{calendar automata}~\cite{bruno}, which is itself inspired by event calendars used in discrete-event simulation.

Calendar automata avoid the problems of encoding timed automata. Rather than encoding ``how much time has passed since the last event'', it encodes ``how far into the future is the next scheduled event'', and a real-valued variable representing the current time is updated to the next event time. Doing so avoids Zeno updates.

Define a set of \emph{events} $e_0, e_1, \ldots, e_n \in E$. We do not define events; intuitively, an event is a set of state variables. When an event is \emph{enabled}, the transitions over events are enabled; otherwise, the variables stutter and maintain the same value.

An \emph{event calendar} $\{ (e_0, t_0), (e_1, t_1), \ldots, (e_n, t_n) \}$ is a set of ordered pairs $(e_i, t_i)$ called \emph{calendar events} where $e_i \in E$ is an event and $t_i \in \mathbb{R}$ is a \emph{timeout}, the time at which the event is scheduled. We denote element $(e_1, t_1)$ of an event calendar by $c_i$.

Let $c$ be an event calendar and $c_i, c_j \in c$ be calendar events. Define an ordering on event calendars such that $c_i \leq c_j$ iff $t_i \leq t_j$, and $min(c) = \{ c_i | \forall c_j \in c, \, c_i \leq c_j  \}$ are the minimum elements of $c$.

Let a transition system $\mathcal{M} = (S, I, \rightarrow)$, be a set of states $S$, a set of initial states $I \subseteq S$, and a transition relation $\rightarrow \subseteq S \times S$. We implicitly assume a set of state variables such that a state $\sigma \in S$ is a total function that maps state variables to values. We distinguish two special state variables in a transition system: (1) $now \in \mathbb{R}$ denotes the current time in the state, and (2) $c$ is an event calendar.

The following laws must hold of a transition system $\mathcal{M}$ implementing a calendar automaton:

\begin{enumerate}
\item Time is initialized to be less than or equal to every calendar timeout: $\forall \sigma \in I, \, \forall (e_i, t_i) \in \sigma(c)$, $\sigma(now) \leq t_i$.
\item In all states, every calendar event occurs no sooner than the current time: $\forall \sigma \in S \, \forall (e_i, t_i) \in \sigma(c)$, $t_i \geq \sigma(now)$.
\item In all states, if the current time is strictly less than every calendar event, then the only enabled transition is a \emph{time progress} update: $\forall \sigma \in S, \, \forall (e_i, t_i) \in \sigma(c)$, if $\sigma(now) < t_i$, then $\forall \sigma'$ such that $\sigma \rightarrow \sigma'$, $\sigma' = \sigma[now := min(c)]$.
\item In all states, if the current time equals a timeout, then the only transition enabled is a calendar event update associated with the timeout: $\forall \sigma \in S, \, \exists (e_i, t_i) \in \sigma(c)$ such that $\sigma(now) = t_i$, then $\forall \sigma'$ such that $\sigma \rightarrow \sigma'$, $\sigma'(now) = \sigma(now)$, $\sigma'(c_j) = \sigma(c_j)$ for all $c_j \in \sigma(c)$ such that $c_j \neq c_i$, and $\sigma'(t_i) > \sigma(t_i)$.
\end{enumerate}

\begin{lemma}[Monotonic time]
$\forall \sigma, \sigma' \in S$, if $\sigma \rightarrow \sigma'$, then $\sigma'(now) \geq \sigma(now)$.
\end{lemma}

In a distributed system, it is convenient to distinguish global actions and local actions. Global actions are principally interprocess communication, while local actions are those carried out by each process to update its local state and produce new messages to broadcast. While both global and local actions can both be modeled as events in a calendar automata, doing so is generally overkill and complicates the model. Real-time constraints matter at the system-level but rarely within an individual process. From the global perspective, individual processes can update their local state atomically.

Following Dutetre and Sorea, we associate calendar events with channels in a distributed system~\cite{dutetre}. Specializing calendars to message passing does not lose generality since all external communication from an individual process can be abstracted as message passing. Furthermore, typical fault models can be abstracted to act over channels rather than processes~\cite{abstractions}. The calendar introduces real-time constraints on when processes send and receive messages.

Assume processes are indexed with the natural numbers $\mathbb{N}$. A \emph{channel} from process $i$ to $j$ is an ordered pair $(i,j)$. Define a set of messages $Msg$, with a designated element $null \in Msg$ denoting the absence of a message. Given a channel and a timeout, let $send$ return the message sent on the channel at that time:
$$send : \mathbb{N} \times \mathbb{N} -> \mathbb{R} -> Msg$$
So $send(i, j, t)$ returns the message that $i$ sends to $j$ at time $t$. Likewise, let
$$recv : \mathbb{N} \times \mathbb{N} -> \mathbb{R} -> Msg$$
compute the message received on that channel at that time, so that $recv(i, j, t)$ returns the message received by $j$ from $i$ at time $t$.

We require that messages received were previously sent and not previously received: if $recv(i, j, t) \neq null$, then $\exists t'$ such that $send(i, j, t')$ where $t' < t$, $recv(i, j, t) = send(i, j, t')$, and $\neg\exists t''$ such that $t' < t'' < t$ and $recv(i, j, t'') = recv(i, j, t)$

Then an event calendar for sending and receiving messages on channels is a set of send or receive events together with their timeouts that yield non-null messages; that is,
$$
\{ (e, t) | \forall i,j: e \neq null \textnormal{ and } (e = send(i, j, t) \textnormal{ or } e = recv(i, j, t))
\}
$$

\lee{technically, atomic time is just a convenience.}
The event of receiving a message initiates a process to update its local state machine and generate additional messages to send. When the process is updating its local state machine, the event calendar is paused. That is, updating an event $recv(i, j, t)$ implicitly includes updating $j$'s state machine.

\lee{note that we don't need full generality of send and receive events in OM(1)}

\subsection{Synchronous Observers}\label{sec:sync}
Synchronous observers are state machines that are synchronously composed with a system specification to check properties over the system's state variables. Synchronous observers are a method for composing specifications with a program. Synchronous observers were first introduced in the context of the synchronous programming languages, such as Lustre~\cite{}. While synchronous observers have been part of model-checking folklore for some time, Rushby systematically describes their application to the domain~\cite{}. The general form for specifying synchronous observers is the following:
$$system | assumptions | requirements$$
\noindent
where `$|$' denotes synchronous composition of state machines.

\paragraph{Fault model}

\paragraph{Property Observer}

% ------------------------------------------------------------
\section{Abstract State Machines}\label{sec:abstract}

% ------------------------------------------------------------
\section{An Extended Example: Byzantine Agreement}\label{sec:byz}

% ------------------------------------------------------------
\section{Experimental Results}\label{sec:experimental}

% ------------------------------------------------------------
\section{Conclusions}\label{sec:conclusions}

\bibliographystyle{IEEEtran}
\bibliography{paper}

\end{document}
